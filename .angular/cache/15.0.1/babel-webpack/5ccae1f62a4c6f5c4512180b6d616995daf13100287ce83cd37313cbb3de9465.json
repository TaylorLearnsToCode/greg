{"ast":null,"code":"import { DiceRolled } from '@shared/model/dice-rolled.model';\nimport { doesExist } from '@shared/utilities/common-util/common.util';\nimport { rollDice } from '@shared/utilities/dice-roller/dice-roller.util';\nimport { MapsAndMagicResult } from '../model/treasure-maps-and-magic.model';\nexport function rollMapsAndMagic(mapsAndMagics) {\n  // loop through the maps and magic array\n  const result = [];\n  mapsAndMagics.forEach(entry => result.push(rollMapOrMagicEntry(entry)));\n  return result;\n}\nconst d100 = new DiceRolled({\n  pips: 100\n});\nfunction rollMapOrMagicEntry(mapOrMagic) {\n  // initialize a blank result\n  const result = new MapsAndMagicResult();\n  // Roll for item chance - returning blank if no item is found\n  if (rollDice(d100) > mapOrMagic.chanceOf) {\n    return result;\n  }\n  // Roll on the provided table a number of times equal to the \"numberOf\"\n  let mapOrMagicItem;\n  for (let i = 0; i < mapOrMagic.numberOf; i++) {\n    mapOrMagicItem = rollOnNestedMagicItemTable(mapOrMagic.entry);\n    if (doesExist(mapOrMagicItem.description) && mapOrMagicItem.description === 'Treasure Map') {\n      result.treasureMaps.push(mapOrMagicItem);\n    } else if (doesExist(mapOrMagicItem.description) && mapOrMagicItem.description === 'Magic Item Map') {\n      result.magicMaps.push(mapOrMagicItem);\n    } else {\n      result.items.push(mapOrMagicItem);\n    }\n  }\n  // return the table\n  return result;\n}\nfunction rollOnNestedMagicItemTable(table) {\n  // roll a chance of\n  const roll = rollDice(d100);\n  // loop through the entry field to assign entry\n  let tableEntry;\n  for (let nestedMagicItemTableEntry of table.entries) {\n    // deterimine the table entry\n    tableEntry = nestedMagicItemTableEntry.entry;\n    /*\r\n    if (!doesExist(tableEntry.entries)) {\r\n      return tableEntry as any as MapOrMagicType;\r\n    }\r\n    */\n    // loop through the entries of the table enrtry to determine the rolled table\n    let targetItemTableEntry;\n    for (let itemTableEntry of tableEntry.entries) {\n      if (roll >= itemTableEntry.chanceOf.low && roll <= itemTableEntry.chanceOf.high) {\n        targetItemTableEntry = itemTableEntry;\n        break;\n      }\n    }\n    // determine the type of the output\n    if (doesExist(targetItemTableEntry.entry.entries)) {\n      // nested list: roll on that list recursively\n      return rollOnNestedMagicItemTable(targetItemTableEntry.entry);\n    } else {\n      // individual item: return this item\n      return targetItemTableEntry.entry;\n    }\n  }\n}","map":{"version":3,"mappings":"AAAA,SAASA,UAAU,QAAQ,iCAAiC;AAC5D,SAASC,SAAS,QAAQ,2CAA2C;AACrE,SAASC,QAAQ,QAAQ,gDAAgD;AAWzE,SAASC,kBAAkB,QAAQ,wCAAwC;AAE3E,OAAM,SAAUC,gBAAgB,CAC9BC,aAAkC;EAElC;EACA,MAAMC,MAAM,GAAyB,EAAE;EACvCD,aAAa,CAACE,OAAO,CAAEC,KAAK,IAAKF,MAAM,CAACG,IAAI,CAACC,mBAAmB,CAACF,KAAK,CAAC,CAAC,CAAC;EACzE,OAAOF,MAAM;AACf;AAEA,MAAMK,IAAI,GAAe,IAAIX,UAAU,CAAC;EAAEY,IAAI,EAAE;AAAG,CAAgB,CAAC;AAIpE,SAASF,mBAAmB,CAC1BG,UAA6B;EAE7B;EACA,MAAMP,MAAM,GAAuB,IAAIH,kBAAkB,EAAE;EAE3D;EACA,IAAID,QAAQ,CAACS,IAAI,CAAC,GAAGE,UAAU,CAACC,QAAQ,EAAE;IACxC,OAAOR,MAAM;;EAGf;EACA,IAAIS,cAA8B;EAClC,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGH,UAAU,CAACI,QAAQ,EAAED,CAAC,EAAE,EAAE;IAC5CD,cAAc,GAAGG,0BAA0B,CAACL,UAAU,CAACL,KAAK,CAAC;IAC7D,IACEP,SAAS,CAACc,cAAc,CAACI,WAAW,CAAC,IACrCJ,cAAc,CAACI,WAAW,KAAK,cAAc,EAC7C;MACAb,MAAM,CAACc,YAAY,CAACX,IAAI,CAACM,cAA6B,CAAC;KACxD,MAAM,IACLd,SAAS,CAACc,cAAc,CAACI,WAAW,CAAC,IACrCJ,cAAc,CAACI,WAAW,KAAK,gBAAgB,EAC/C;MACAb,MAAM,CAACe,SAAS,CAACZ,IAAI,CAACM,cAA8B,CAAC;KACtD,MAAM;MACLT,MAAM,CAACgB,KAAK,CAACb,IAAI,CAACM,cAA2B,CAAC;;;EAIlD;EACA,OAAOT,MAAM;AACf;AAEA,SAASY,0BAA0B,CACjCK,KAA2B;EAE3B;EACA,MAAMC,IAAI,GAAWtB,QAAQ,CAACS,IAAI,CAAC;EAEnC;EACA,IAAIc,UAAiD;EACrD,KAAK,IAAIC,yBAAyB,IAAIH,KAAK,CAACI,OAAO,EAAE;IACnD;IACAF,UAAU,GAAGC,yBAAyB,CAAClB,KAAK;IAE5C;;;;;IAMA;IACA,IAAIoB,oBAAyB;IAC7B,KAAK,IAAIC,cAAc,IAAIJ,UAAU,CAACE,OAAO,EAAE;MAC7C,IACEH,IAAI,IAAIK,cAAc,CAACf,QAAQ,CAACgB,GAAG,IACnCN,IAAI,IAAIK,cAAc,CAACf,QAAQ,CAACiB,IAAI,EACpC;QACAH,oBAAoB,GAAGC,cAAc;QACrC;;;IAIJ;IACA,IAAI5B,SAAS,CAAC2B,oBAAoB,CAACpB,KAAK,CAACmB,OAAO,CAAC,EAAE;MACjD;MACA,OAAOT,0BAA0B,CAACU,oBAAoB,CAACpB,KAAK,CAAC;KAC9D,MAAM;MACL;MACA,OAAOoB,oBAAoB,CAACpB,KAAK;;;AAGvC","names":["DiceRolled","doesExist","rollDice","MapsAndMagicResult","rollMapsAndMagic","mapsAndMagics","result","forEach","entry","push","rollMapOrMagicEntry","d100","pips","mapOrMagic","chanceOf","mapOrMagicItem","i","numberOf","rollOnNestedMagicItemTable","description","treasureMaps","magicMaps","items","table","roll","tableEntry","nestedMagicItemTableEntry","entries","targetItemTableEntry","itemTableEntry","low","high"],"sourceRoot":"","sources":["D:\\workspaces\\greg\\src\\app\\treasure\\enter-treasure\\utilities\\map-and-magic-roller.util.ts"],"sourcesContent":["import { DiceRolled } from '@shared/model/dice-rolled.model';\r\nimport { doesExist } from '@shared/utilities/common-util/common.util';\r\nimport { rollDice } from '@shared/utilities/dice-roller/dice-roller.util';\r\nimport {\r\n  MagicItem,\r\n  MagicItemTable,\r\n  NestedMagicItemTable,\r\n} from '@treasure/treasure-common/model/magic-item.model';\r\nimport {\r\n  MagicItemMap,\r\n  TreasureMap,\r\n} from '@treasure/treasure-common/model/treasure-map.model';\r\nimport { MapsAndMagicEntry } from '../model/treasure-list-entry.model';\r\nimport { MapsAndMagicResult } from '../model/treasure-maps-and-magic.model';\r\n\r\nexport function rollMapsAndMagic(\r\n  mapsAndMagics: MapsAndMagicEntry[]\r\n): MapsAndMagicResult[] {\r\n  // loop through the maps and magic array\r\n  const result: MapsAndMagicResult[] = [];\r\n  mapsAndMagics.forEach((entry) => result.push(rollMapOrMagicEntry(entry)));\r\n  return result;\r\n}\r\n\r\nconst d100: DiceRolled = new DiceRolled({ pips: 100 } as DiceRolled);\r\n\r\ntype MapOrMagicType = MagicItem | TreasureMap | MagicItemMap;\r\n\r\nfunction rollMapOrMagicEntry(\r\n  mapOrMagic: MapsAndMagicEntry\r\n): MapsAndMagicResult {\r\n  // initialize a blank result\r\n  const result: MapsAndMagicResult = new MapsAndMagicResult();\r\n\r\n  // Roll for item chance - returning blank if no item is found\r\n  if (rollDice(d100) > mapOrMagic.chanceOf) {\r\n    return result;\r\n  }\r\n\r\n  // Roll on the provided table a number of times equal to the \"numberOf\"\r\n  let mapOrMagicItem: MapOrMagicType;\r\n  for (let i = 0; i < mapOrMagic.numberOf; i++) {\r\n    mapOrMagicItem = rollOnNestedMagicItemTable(mapOrMagic.entry);\r\n    if (\r\n      doesExist(mapOrMagicItem.description) &&\r\n      mapOrMagicItem.description === 'Treasure Map'\r\n    ) {\r\n      result.treasureMaps.push(mapOrMagicItem as TreasureMap);\r\n    } else if (\r\n      doesExist(mapOrMagicItem.description) &&\r\n      mapOrMagicItem.description === 'Magic Item Map'\r\n    ) {\r\n      result.magicMaps.push(mapOrMagicItem as MagicItemMap);\r\n    } else {\r\n      result.items.push(mapOrMagicItem as MagicItem);\r\n    }\r\n  }\r\n\r\n  // return the table\r\n  return result;\r\n}\r\n\r\nfunction rollOnNestedMagicItemTable(\r\n  table: NestedMagicItemTable\r\n): MapOrMagicType {\r\n  // roll a chance of\r\n  const roll: number = rollDice(d100);\r\n\r\n  // loop through the entry field to assign entry\r\n  let tableEntry: MagicItemTable | NestedMagicItemTable;\r\n  for (let nestedMagicItemTableEntry of table.entries) {\r\n    // deterimine the table entry\r\n    tableEntry = nestedMagicItemTableEntry.entry;\r\n\r\n    /*\r\n    if (!doesExist(tableEntry.entries)) {\r\n      return tableEntry as any as MapOrMagicType;\r\n    }\r\n    */\r\n\r\n    // loop through the entries of the table enrtry to determine the rolled table\r\n    let targetItemTableEntry: any;\r\n    for (let itemTableEntry of tableEntry.entries) {\r\n      if (\r\n        roll >= itemTableEntry.chanceOf.low &&\r\n        roll <= itemTableEntry.chanceOf.high\r\n      ) {\r\n        targetItemTableEntry = itemTableEntry;\r\n        break;\r\n      }\r\n    }\r\n\r\n    // determine the type of the output\r\n    if (doesExist(targetItemTableEntry.entry.entries)) {\r\n      // nested list: roll on that list recursively\r\n      return rollOnNestedMagicItemTable(targetItemTableEntry.entry);\r\n    } else {\r\n      // individual item: return this item\r\n      return targetItemTableEntry.entry;\r\n    }\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"import { DiceRolled } from '@shared/model/dice-rolled.model';\nimport { doesExist } from '@shared/utilities/common-util/common.util';\nimport { isWithinRange, rollDice } from '@shared/utilities/dice-roller/dice-roller.util';\nimport { MagicItemMapResult, MapsAndMagicResult, TreasureMapResult } from '../model/treasure-maps-and-magic.model';\nimport { rollGems } from './gem-roller.util';\nimport { rollJewelry } from './jewelry-roller.util';\nexport function rollMapsAndMagic(mapsAndMagics) {\n  // loop through the maps and magic array\n  const result = [];\n  mapsAndMagics.forEach(entry => result.push(rollMapOrMagicEntry(entry)));\n  return result;\n}\nconst d100 = new DiceRolled({\n  pips: 100\n});\nfunction findTableToRollOn(table) {\n  const roll = rollDice(d100);\n  let targetEntry;\n  for (let tableEntry of table.entries) {\n    if (isWithinRange(roll, tableEntry.chanceOf)) {\n      targetEntry = tableEntry;\n      break;\n    }\n  }\n  // if the first result of the target entry's entries has entries, recusion!\n  const targetEntryTable = targetEntry.entry;\n  if (doesExist(targetEntryTable.entries) && doesExist(targetEntryTable.entries[0].entries)) {\n    return findTableToRollOn(targetEntryTable);\n  } else {\n    return targetEntryTable;\n  }\n}\nfunction rollMapOrMagicEntry(mapOrMagic) {\n  // initialize a blank result\n  const result = new MapsAndMagicResult();\n  // Roll for item chance - returning blank if no item is found\n  if (rollDice(d100) > mapOrMagic.chanceOf) {\n    return result;\n  }\n  // Roll on the provided table a number of times equal to the \"numberOf\"\n  let mapOrMagicItem;\n  for (let i = 0; i < mapOrMagic.numberOf; i++) {\n    mapOrMagicItem = rollOnNestedMagicItemTable(mapOrMagic.entry);\n    if (doesExist(mapOrMagicItem.silver) || doesExist(mapOrMagicItem.gold) || doesExist(mapOrMagicItem.gems) || doesExist(mapOrMagicItem.jewelry)) {\n      result.treasureMaps.push(rollTreasureMapResult(mapOrMagicItem));\n    } else if (doesExist(mapOrMagicItem.treasure)) {\n      result.magicMaps.push(rollMagicItemMapResult(mapOrMagicItem));\n    } else {\n      result.items.push(mapOrMagicItem);\n    }\n  }\n  // return the table\n  return result;\n}\nfunction rollOnNestedMagicItemTable(table) {\n  // find table to roll on, under the nesting\n  const targetTableEntry = findTableToRollOn(table);\n  // roll a chance of\n  const roll = rollDice(d100);\n  // find the result in the tableEntry\n  for (let resultItem of targetTableEntry.entries) {\n    if (isWithinRange(roll, resultItem.chanceOf)) {\n      if (resultItem.entry.entries) {\n        return rollEntries(resultItem.entry);\n      } else {\n        return resultItem.entry;\n      }\n    }\n  }\n  // if you've gotten to this point, the roll was out of bounds\n  throw new Error(`Roll result ${roll} on ${targetTableEntry.name} did not return an entry`);\n}\nfunction rollEntries(table) {\n  const roll = rollDice(d100);\n  for (let item of table.entries) {\n    if (isWithinRange(roll, item.chanceOf)) {\n      return item.entry;\n    }\n  }\n}\nfunction rollTreasureMapResult(map) {\n  const result = new TreasureMapResult();\n  result.silver = rollDice(map.silver);\n  result.gold = rollDice(map.gold);\n  result.gems = rollGems([{\n    numberOf: map.gems\n  }])[0];\n  result.jewelry = rollJewelry([{\n    numberOf: map.jewelry\n  }])[0];\n  return result;\n}\nfunction rollMagicItemMapResult(map) {\n  const result = new MagicItemMapResult();\n  for (let rolledItems of rollMapsAndMagic(map.treasure)) {\n    for (let magicItem of rolledItems.items) {\n      result.items.push(magicItem);\n    }\n  }\n  return result;\n}","map":{"version":3,"mappings":"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","names":["DiceRolled","doesExist","isWithinRange","rollDice","MagicItemMapResult","MapsAndMagicResult","TreasureMapResult","rollGems","rollJewelry","rollMapsAndMagic","mapsAndMagics","result","forEach","entry","push","rollMapOrMagicEntry","d100","pips","findTableToRollOn","table","roll","targetEntry","tableEntry","entries","chanceOf","targetEntryTable","mapOrMagic","mapOrMagicItem","i","numberOf","rollOnNestedMagicItemTable","silver","gold","gems","jewelry","treasureMaps","rollTreasureMapResult","treasure","magicMaps","rollMagicItemMapResult","items","targetTableEntry","resultItem","rollEntries","Error","name","item","map","rolledItems","magicItem"],"sourceRoot":"","sources":["D:\\workspaces\\greg\\src\\app\\treasure\\enter-treasure\\utilities\\map-and-magic-roller.util.ts"],"sourcesContent":["import { DiceRolled } from '@shared/model/dice-rolled.model';\r\nimport { doesExist } from '@shared/utilities/common-util/common.util';\r\nimport {\r\n  isWithinRange,\r\n  rollDice,\r\n} from '@shared/utilities/dice-roller/dice-roller.util';\r\nimport {\r\n  MagicItem,\r\n  MagicItemTable,\r\n  MagicItemTableEntry,\r\n  NestedMagicItemTable,\r\n  NestedMagicItemTableEntry,\r\n} from '@treasure/treasure-common/model/magic-item.model';\r\nimport {\r\n  MagicItemMap,\r\n  TreasureMap,\r\n} from '@treasure/treasure-common/model/treasure-map.model';\r\nimport {\r\n  GemOrJewel,\r\n  MapsAndMagicEntry,\r\n} from '../model/treasure-list-entry.model';\r\nimport {\r\n  MagicItemMapResult,\r\n  MapsAndMagicResult,\r\n  TreasureMapResult,\r\n} from '../model/treasure-maps-and-magic.model';\r\nimport { rollGems } from './gem-roller.util';\r\nimport { rollJewelry } from './jewelry-roller.util';\r\n\r\nexport function rollMapsAndMagic(\r\n  mapsAndMagics: MapsAndMagicEntry[]\r\n): MapsAndMagicResult[] {\r\n  // loop through the maps and magic array\r\n  const result: MapsAndMagicResult[] = [];\r\n  mapsAndMagics.forEach((entry) => result.push(rollMapOrMagicEntry(entry)));\r\n  return result;\r\n}\r\n\r\nconst d100: DiceRolled = new DiceRolled({ pips: 100 } as DiceRolled);\r\n\r\ntype MapOrMagicType = MagicItem | TreasureMap | MagicItemMap;\r\n\r\nfunction findTableToRollOn(\r\n  table: MagicItemTable | NestedMagicItemTable\r\n): MagicItemTable {\r\n  const roll: number = rollDice(d100);\r\n  let targetEntry: MagicItemTableEntry | NestedMagicItemTableEntry;\r\n  for (let tableEntry of table.entries) {\r\n    if (isWithinRange(roll, tableEntry.chanceOf)) {\r\n      targetEntry = tableEntry;\r\n      break;\r\n    }\r\n  }\r\n\r\n  // if the first result of the target entry's entries has entries, recusion!\r\n  const targetEntryTable: any = targetEntry.entry;\r\n  if (\r\n    doesExist(targetEntryTable.entries) &&\r\n    doesExist(targetEntryTable.entries[0].entries)\r\n  ) {\r\n    return findTableToRollOn(targetEntryTable);\r\n  } else {\r\n    return targetEntryTable;\r\n  }\r\n}\r\n\r\nfunction rollMapOrMagicEntry(\r\n  mapOrMagic: MapsAndMagicEntry\r\n): MapsAndMagicResult {\r\n  // initialize a blank result\r\n  const result: MapsAndMagicResult = new MapsAndMagicResult();\r\n\r\n  // Roll for item chance - returning blank if no item is found\r\n  if (rollDice(d100) > mapOrMagic.chanceOf) {\r\n    return result;\r\n  }\r\n\r\n  // Roll on the provided table a number of times equal to the \"numberOf\"\r\n  let mapOrMagicItem: MapOrMagicType;\r\n  for (let i = 0; i < mapOrMagic.numberOf; i++) {\r\n    mapOrMagicItem = rollOnNestedMagicItemTable(mapOrMagic.entry);\r\n    if (\r\n      doesExist((mapOrMagicItem as TreasureMap).silver) ||\r\n      doesExist((mapOrMagicItem as TreasureMap).gold) ||\r\n      doesExist((mapOrMagicItem as TreasureMap).gems) ||\r\n      doesExist((mapOrMagicItem as TreasureMap).jewelry)\r\n    ) {\r\n      result.treasureMaps.push(\r\n        rollTreasureMapResult(mapOrMagicItem as TreasureMap)\r\n      );\r\n    } else if (doesExist((mapOrMagicItem as MagicItemMap).treasure)) {\r\n      result.magicMaps.push(\r\n        rollMagicItemMapResult(mapOrMagicItem as MagicItemMap)\r\n      );\r\n    } else {\r\n      result.items.push(mapOrMagicItem as MagicItem);\r\n    }\r\n  }\r\n\r\n  // return the table\r\n  return result;\r\n}\r\n\r\nfunction rollOnNestedMagicItemTable(\r\n  table: MagicItemTable | NestedMagicItemTable\r\n): MapOrMagicType {\r\n  // find table to roll on, under the nesting\r\n  const targetTableEntry: MagicItemTable = findTableToRollOn(\r\n    table\r\n  ) as MagicItemTable;\r\n\r\n  // roll a chance of\r\n  const roll: number = rollDice(d100);\r\n\r\n  // find the result in the tableEntry\r\n  for (let resultItem of targetTableEntry.entries) {\r\n    if (isWithinRange(roll, resultItem.chanceOf)) {\r\n      if ((resultItem.entry as any).entries) {\r\n        return rollEntries(resultItem.entry as any);\r\n      } else {\r\n        return resultItem.entry;\r\n      }\r\n    }\r\n  }\r\n\r\n  // if you've gotten to this point, the roll was out of bounds\r\n  throw new Error(\r\n    `Roll result ${roll} on ${targetTableEntry.name} did not return an entry`\r\n  );\r\n}\r\n\r\nfunction rollEntries(table: MagicItemTable): MapOrMagicType {\r\n  const roll: number = rollDice(d100);\r\n  for (let item of table.entries) {\r\n    if (isWithinRange(roll, item.chanceOf)) {\r\n      return item.entry;\r\n    }\r\n  }\r\n}\r\n\r\nfunction rollTreasureMapResult(map: TreasureMap): TreasureMapResult {\r\n  const result: TreasureMapResult = new TreasureMapResult();\r\n  result.silver = rollDice(map.silver);\r\n  result.gold = rollDice(map.gold);\r\n  result.gems = rollGems([{ numberOf: map.gems } as GemOrJewel])[0];\r\n  result.jewelry = rollJewelry([{ numberOf: map.jewelry } as GemOrJewel])[0];\r\n  return result;\r\n}\r\n\r\nfunction rollMagicItemMapResult(map: MagicItemMap): MagicItemMapResult {\r\n  const result: MagicItemMapResult = new MagicItemMapResult();\r\n  for (let rolledItems of rollMapsAndMagic(map.treasure as any)) {\r\n    for (let magicItem of rolledItems.items) {\r\n      result.items.push(magicItem);\r\n    }\r\n  }\r\n  return result;\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}
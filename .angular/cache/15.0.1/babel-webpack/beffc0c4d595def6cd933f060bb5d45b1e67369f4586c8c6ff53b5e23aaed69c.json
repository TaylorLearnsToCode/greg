{"ast":null,"code":"import { DiceRolled } from '@shared/model/dice-rolled.model';\nimport { doesExist } from '@shared/utilities/common-util/common.util';\nimport { rollDice } from '@shared/utilities/dice-roller/dice-roller.util';\nimport { JewelRollResult, RolledJewelValues } from '@treasure/enter-treasure/model/treasure-jewelry.model';\nimport { TreasureRollResult } from '@treasure/enter-treasure/model/treasure-list-entry.model';\nimport { MapsAndMagicResult } from '@treasure/enter-treasure/model/treasure-maps-and-magic.model';\nimport { rollGems } from '@treasure/enter-treasure/utilities/gem-roller.util';\nimport { BehaviorSubject } from 'rxjs';\nimport * as i0 from \"@angular/core\";\nexport class RollTreasureControllerService {\n  constructor() {\n    this.areEnteringTreasure = new BehaviorSubject(true);\n    this.rolledTreasureSource = new BehaviorSubject(null);\n    this.d6 = new DiceRolled({\n      no: 1,\n      pips: 6\n    });\n    this.d100 = new DiceRolled({\n      no: 1,\n      pips: 100\n    });\n    this.areEnteringTreasure$ = this.areEnteringTreasure.asObservable();\n    this.rolledTreasure$ = this.rolledTreasureSource.asObservable();\n  }\n  set rolledTreasure(treasure) {\n    this.rolledTreasureSource.next(treasure);\n  }\n  toggleAreEnteringTreasure() {\n    this.areEnteringTreasure.next(!this.areEnteringTreasure.value);\n  }\n  rollTreasure(treasureList) {\n    const rolledTreasure = new TreasureRollResult();\n    rolledTreasure.copper = this.rollSpecie(treasureList.copper);\n    rolledTreasure.silver = this.rollSpecie(treasureList.silver);\n    rolledTreasure.gold = this.rollSpecie(treasureList.gold);\n    rolledTreasure.mapsAndMagic = this.rollMapsAndMagic(treasureList.mapsAndMagic);\n    rolledTreasure.gems = rollGems(treasureList.gems);\n    rolledTreasure.jewelry = this.rollJewelry(treasureList.jewelry);\n    this.rolledTreasure = rolledTreasure;\n  }\n  rollJewelry(jewelry) {\n    const result = [];\n    jewelry.forEach(jewel => result.push(this.rollJewel(jewel)));\n    return result;\n  }\n  rollJewel(jewel) {\n    const result = new JewelRollResult();\n    if (rollDice(this.d100) > jewel.chanceOf) {\n      return result;\n    }\n    const jewels = [];\n    let roll;\n    let valuation;\n    for (let i = 0; i < rollDice(jewel.numberOf); i++) {\n      roll = rollDice(this.d100);\n      RolledJewelValues.forEach((value, key) => {\n        if (roll <= key) {\n          valuation = value;\n        }\n      });\n      jewels.push(rollDice(valuation));\n    }\n    result.values = jewels;\n    return result;\n  }\n  findTargetTable(table) {\n    let targetTable;\n    if (doesExist(table.entry)) {\n      targetTable = table.entry;\n    } else {\n      targetTable = this.findTargetTable(table);\n    }\n    return targetTable;\n  }\n  rollOnNestedMagicItemTable(table) {\n    let targetTable;\n    let result = [];\n    for (let tableEntry of table.entries) {\n      targetTable = this.findTargetTable(tableEntry);\n      const roll = rollDice(this.d100);\n      for (let item of targetTable.entries) {\n        if (roll >= item.chanceOf.low && roll <= item.chanceOf.high) {\n          if (doesExist(item.entries)) {\n            this.rollOnMagicItemTable(item);\n          } else {\n            result.push(item.entry);\n          }\n          break;\n        }\n      }\n    }\n    return result;\n  }\n  rollOnMagicItemTable(table) {\n    const roll = rollDice(this.d100);\n    let targetEntry;\n    for (let entry of table.entries) {\n      if (roll >= entry.chanceOf.low && roll <= entry.chanceOf.high) {\n        targetEntry = entry;\n        break;\n      }\n    }\n    if (doesExist(table.entries)) {\n      return this.rollOnMagicItemTable(targetEntry);\n    } else if (doesExist(targetEntry.entry)) {\n      return targetEntry.entry;\n    }\n  }\n  rollMapOrMagicItem(item) {\n    const result = new MapsAndMagicResult();\n    if (rollDice(this.d100) > item.chanceOf) {\n      return result;\n    }\n    let rolledMapOrMagicItem;\n    for (let i = 0; i < item.numberOf; i++) {\n      rolledMapOrMagicItem = this.rollOnNestedMagicItemTable(item.entry);\n      rolledMapOrMagicItem.forEach(item => {\n        if (item.description === 'Treasure Map') {} else if (item.description === 'Magic Item Map') {} else {\n          result.items.push(item);\n        }\n      });\n    }\n    return result;\n  }\n  rollMapsAndMagic(mapsAndMagic) {\n    const result = [];\n    mapsAndMagic.forEach(mapOrMagic => result.push(this.rollMapOrMagicItem(mapOrMagic)));\n    return result;\n  }\n  rollSpecie(specie) {\n    return rollDice(this.d100) <= specie.chanceOf ? rollDice(specie.amount) : 0;\n  }\n}\nRollTreasureControllerService.ɵfac = function RollTreasureControllerService_Factory(t) {\n  return new (t || RollTreasureControllerService)();\n};\nRollTreasureControllerService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: RollTreasureControllerService,\n  factory: RollTreasureControllerService.ɵfac,\n  providedIn: 'root'\n});","map":{"version":3,"mappings":"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","names":["DiceRolled","doesExist","rollDice","JewelRollResult","RolledJewelValues","TreasureRollResult","MapsAndMagicResult","rollGems","BehaviorSubject","RollTreasureControllerService","constructor","no","pips","areEnteringTreasure","asObservable","rolledTreasureSource","rolledTreasure","treasure","next","toggleAreEnteringTreasure","value","rollTreasure","treasureList","copper","rollSpecie","silver","gold","mapsAndMagic","rollMapsAndMagic","gems","jewelry","rollJewelry","result","forEach","jewel","push","rollJewel","d100","chanceOf","jewels","roll","valuation","i","numberOf","key","values","findTargetTable","table","targetTable","entry","rollOnNestedMagicItemTable","tableEntry","entries","item","low","high","rollOnMagicItemTable","targetEntry","rollMapOrMagicItem","rolledMapOrMagicItem","description","items","mapOrMagic","specie","amount","factory","providedIn"],"sourceRoot":"","sources":["D:\\workspaces\\greg\\src\\app\\treasure\\enter-treasure\\services\\roll-treasure-controller\\roll-treasure-controller.service.ts"],"sourcesContent":["import { Injectable } from '@angular/core';\nimport { DiceRolled } from '@shared/model/dice-rolled.model';\nimport { doesExist } from '@shared/utilities/common-util/common.util';\nimport { rollDice } from '@shared/utilities/dice-roller/dice-roller.util';\nimport {\n  JewelRollResult,\n  RolledJewelValues,\n} from '@treasure/enter-treasure/model/treasure-jewelry.model';\nimport {\n  GemOrJewel,\n  MapsAndMagicEntry,\n  Specie,\n  TreasureListEntry,\n  TreasureRollResult,\n} from '@treasure/enter-treasure/model/treasure-list-entry.model';\nimport { MapsAndMagicResult } from '@treasure/enter-treasure/model/treasure-maps-and-magic.model';\nimport { rollGems } from '@treasure/enter-treasure/utilities/gem-roller.util';\nimport {\n  MagicItem,\n  MagicItemTable,\n  NestedMagicItemTable,\n  NestedMagicItemTableEntry,\n} from '@treasure/treasure-common/model/magic-item.model';\nimport {\n  MagicItemMap,\n  TreasureMap,\n} from '@treasure/treasure-common/model/treasure-map.model';\nimport { BehaviorSubject, Observable } from 'rxjs';\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class RollTreasureControllerService {\n  private areEnteringTreasure: BehaviorSubject<boolean> = new BehaviorSubject(\n    true\n  );\n  private rolledTreasureSource: BehaviorSubject<TreasureRollResult> =\n    new BehaviorSubject(null);\n  private set rolledTreasure(treasure: TreasureRollResult) {\n    this.rolledTreasureSource.next(treasure);\n  }\n\n  private readonly d6: DiceRolled = new DiceRolled({\n    no: 1,\n    pips: 6,\n  } as DiceRolled);\n  private readonly d100: DiceRolled = new DiceRolled({\n    no: 1,\n    pips: 100,\n  } as DiceRolled);\n\n  areEnteringTreasure$: Observable<boolean> =\n    this.areEnteringTreasure.asObservable();\n  rolledTreasure$: Observable<TreasureRollResult> =\n    this.rolledTreasureSource.asObservable();\n\n  constructor() {}\n\n  toggleAreEnteringTreasure(): void {\n    this.areEnteringTreasure.next(!this.areEnteringTreasure.value);\n  }\n\n  rollTreasure(treasureList: TreasureListEntry): void {\n    const rolledTreasure: TreasureRollResult = new TreasureRollResult();\n    rolledTreasure.copper = this.rollSpecie(treasureList.copper);\n    rolledTreasure.silver = this.rollSpecie(treasureList.silver);\n    rolledTreasure.gold = this.rollSpecie(treasureList.gold);\n    rolledTreasure.mapsAndMagic = this.rollMapsAndMagic(\n      treasureList.mapsAndMagic\n    );\n    rolledTreasure.gems = rollGems(treasureList.gems);\n    rolledTreasure.jewelry = this.rollJewelry(treasureList.jewelry);\n    this.rolledTreasure = rolledTreasure;\n  }\n\n  private rollJewelry(jewelry: GemOrJewel[]): JewelRollResult[] {\n    const result: JewelRollResult[] = [];\n    jewelry.forEach((jewel) => result.push(this.rollJewel(jewel)));\n    return result;\n  }\n\n  private rollJewel(jewel: GemOrJewel): JewelRollResult {\n    const result: JewelRollResult = new JewelRollResult();\n\n    if (rollDice(this.d100) > jewel.chanceOf) {\n      return result;\n    }\n\n    const jewels: number[] = [];\n    let roll: number;\n    let valuation: DiceRolled;\n    for (let i = 0; i < rollDice(jewel.numberOf); i++) {\n      roll = rollDice(this.d100);\n\n      RolledJewelValues.forEach((value: DiceRolled, key: number) => {\n        if (roll <= key) {\n          valuation = value;\n        }\n      });\n\n      jewels.push(rollDice(valuation));\n    }\n\n    result.values = jewels;\n    return result;\n  }\n\n  private findTargetTable(table: NestedMagicItemTableEntry): MagicItemTable {\n    let targetTable: MagicItemTable;\n    if (doesExist(table.entry)) {\n      targetTable = table.entry as MagicItemTable;\n    } else {\n      targetTable = this.findTargetTable(table);\n    }\n    return targetTable;\n  }\n\n  private rollOnNestedMagicItemTable(\n    table: NestedMagicItemTable\n  ): Array<MagicItem | TreasureMap | MagicItemMap> {\n    let targetTable: MagicItemTable;\n    let result: Array<MagicItem | TreasureMap | MagicItemMap> = [];\n    for (let tableEntry of table.entries) {\n      targetTable = this.findTargetTable(tableEntry);\n      const roll = rollDice(this.d100);\n      for (let item of targetTable.entries) {\n        if (roll >= item.chanceOf.low && roll <= item.chanceOf.high) {\n          if (doesExist((item as any).entries)) {\n            this.rollOnMagicItemTable(item as any as MagicItemTable);\n          } else {\n            result.push(item.entry);\n          }\n          break;\n        }\n      }\n    }\n    return result;\n  }\n\n  private rollOnMagicItemTable(\n    table: MagicItemTable\n  ): MagicItem | TreasureMap | MagicItemMap {\n    const roll = rollDice(this.d100);\n    let targetEntry;\n    for (let entry of table.entries) {\n      if (roll >= entry.chanceOf.low && roll <= entry.chanceOf.high) {\n        targetEntry = entry;\n        break;\n      }\n    }\n\n    if (doesExist((table as any).entries)) {\n      return this.rollOnMagicItemTable(targetEntry);\n    } else if (doesExist(targetEntry.entry)) {\n      return targetEntry.entry;\n    }\n  }\n\n  private rollMapOrMagicItem(item: MapsAndMagicEntry): MapsAndMagicResult {\n    const result: MapsAndMagicResult = new MapsAndMagicResult();\n\n    if (rollDice(this.d100) > item.chanceOf) {\n      return result;\n    }\n\n    let rolledMapOrMagicItem: Array<MagicItem | TreasureMap | MagicItemMap>;\n    for (let i = 0; i < item.numberOf; i++) {\n      rolledMapOrMagicItem = this.rollOnNestedMagicItemTable(item.entry);\n      rolledMapOrMagicItem.forEach((item) => {\n        if (item.description === 'Treasure Map') {\n        } else if (item.description === 'Magic Item Map') {\n        } else {\n          result.items.push(item);\n        }\n      });\n    }\n    return result;\n  }\n\n  private rollMapsAndMagic(\n    mapsAndMagic: MapsAndMagicEntry[]\n  ): MapsAndMagicResult[] {\n    const result: MapsAndMagicResult[] = [];\n    mapsAndMagic.forEach((mapOrMagic) =>\n      result.push(this.rollMapOrMagicItem(mapOrMagic))\n    );\n    return result;\n  }\n\n  private rollSpecie(specie: Specie): number {\n    return rollDice(this.d100) <= specie.chanceOf ? rollDice(specie.amount) : 0;\n  }\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"/**\r\n * For any two objects, returns TRUE if all properties and sub-properties, recursively, match.\r\n * @param  {any} first\r\n * @param  {any} second\r\n */\nexport function areEqual(first, second) {\n  if (!doesExist(first) && doesExist(second) || doesExist(first) && !doesExist(second)) {\n    return false;\n  } else if (!doesExist(first) && !doesExist(second)) {\n    return true;\n  } else if (Array.isArray(first) && Array.isArray(second)) {\n    return areArraysEqual(first, second);\n  } else if (first instanceof Date && second instanceof Date) {\n    return first.valueOf() === second.valueOf();\n  } else if (typeof first === 'object' && typeof second === typeof first) {\n    return areObjectsEqual(first, second);\n  } else {\n    return first === second;\n  }\n}\n/**\r\n * Performs a deep-clone of a provided object: such that the object is new (not\r\n * a reference) and all of its properties are likewise new.\r\n * @param  {any} obj\r\n */\nexport function cloneObject(obj) {\n  let retObj;\n  if (!doesExist(obj)) {\n    return null;\n  } else if (Array.isArray(obj)) {\n    retObj = [];\n    obj.forEach(element => retObj.push(cloneObject(element)));\n  } else if (typeof obj === 'object' && !(obj instanceof Date)) {\n    retObj = {};\n    Object.keys(obj).forEach(key => retObj[key] = cloneObject(obj[key]));\n  } else if (obj instanceof Date) {\n    retObj = new Date(obj.valueOf());\n  } else {\n    retObj = obj;\n  }\n  return retObj;\n}\n/**\r\n * For a provided object, replaces the object's properties with the corresponding\r\n * properties of a provided object argument.\r\n * @param  {any} arg?\r\n * @param  {any} obj?\r\n * @returns void\r\n */\nexport function constructInstance(arg, obj) {\n  if (doesExist(arg) && doesExist(obj)) {\n    Object.keys(obj).forEach(key => {\n      if (doesExist(arg[key])) {\n        obj[key] = arg[key];\n      }\n    });\n  }\n}\n/**\r\n * For any object, iterate through properties and Object.freeze each.\r\n * @param  {any} obj\r\n */\nexport function deepFreeze(obj) {\n  if (!doesExist(obj)) {\n    return;\n  } else if (Array.isArray(obj)) {\n    obj.forEach(element => deepFreeze(element));\n  } else if (typeof obj === 'object' && !(obj instanceof Date)) {\n    Object.keys(obj).forEach(key => deepFreeze(obj[key]));\n  }\n  Object.freeze(obj);\n}\n/**\r\n * Returns TRUE if the provided object is neither NULL nor UNDEFINED.\r\n * @param  {any} obj\r\n */\nexport function doesExist(obj) {\n  return obj !== null && obj !== undefined;\n}\n/**\r\n * Returns whether or not the provided object is defined, but empty.\r\n * * An empty array is defined as an array with no entries\r\n * * An empty string is defined as a string with no characters\r\n * @param  {string|any[]} obj\r\n */\nexport function isEmpty(obj) {\n  if (Array.isArray(obj)) {\n    return isArrayEmpty(obj);\n  } else if (typeof obj === 'object') {\n    return Object.keys(obj).length === 0;\n  } else {\n    return isStringEmpty(obj);\n  }\n}\n/**\r\n * Verifies that two objects have the same number of properties on their prototype\r\n * and then iterates through properties, verifying that the values assigned to each\r\n * property are likewise equivalent.\r\n * @param  {any} first\r\n * @param  {any} second\r\n */\nfunction areObjectsEqual(first, second) {\n  const firstKeys = Object.keys(first);\n  let equal = firstKeys.length === Object.keys(second).length;\n  if (equal) {\n    equal = !firstKeys.some(key => !areEqual(first[key], second[key]));\n  }\n  return equal;\n}\n/**\r\n * Verifies that two provided arrays both have the same number of elements and\r\n * that each element is equivalent to a corresponding element at the same index\r\n * in its provided sister array.\r\n * @param  {any[]} first\r\n * @param  {any[]} second\r\n */\nfunction areArraysEqual(first, second) {\n  let equal = first.length === second.length;\n  if (equal) {\n    equal = !first.some((val, idx) => !areEqual(val, second[idx]));\n  }\n  return equal;\n}\n/**\r\n * Returns TRUE if an array a is neither NULL nor UNDEFINED but contains\r\n * 0 entries within it.\r\n * @param  {any[]} a\r\n */\nfunction isArrayEmpty(a) {\n  return doesExist(a) && a.length === 0;\n}\n/**\r\n * Returns TRUE if a string s is neither NULL nor UNDEFINED but does\r\n * have a length of 0.\r\n * @param  {string} s\r\n */\nfunction isStringEmpty(s) {\n  return doesExist(s) && s.length === 0;\n}","map":{"version":3,"mappings":"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","names":["areEqual","first","second","doesExist","Array","isArray","areArraysEqual","Date","valueOf","areObjectsEqual","cloneObject","obj","retObj","forEach","element","push","Object","keys","key","constructInstance","arg","deepFreeze","freeze","undefined","isEmpty","isArrayEmpty","length","isStringEmpty","firstKeys","equal","some","val","idx","a","s"],"sourceRoot":"","sources":["D:\\workspaces\\greg\\src\\app\\shared\\utilities\\common-util\\common.util.ts"],"sourcesContent":["/**\r\n * For any two objects, returns TRUE if all properties and sub-properties, recursively, match.\r\n * @param  {any} first\r\n * @param  {any} second\r\n */\r\nexport function areEqual(first: any, second: any): boolean {\r\n  if (\r\n    (!doesExist(first) && doesExist(second)) ||\r\n    (doesExist(first) && !doesExist(second))\r\n  ) {\r\n    return false;\r\n  } else if (!doesExist(first) && !doesExist(second)) {\r\n    return true;\r\n  } else if (Array.isArray(first) && Array.isArray(second)) {\r\n    return areArraysEqual(first, second);\r\n  } else if (first instanceof Date && second instanceof Date) {\r\n    return first.valueOf() === second.valueOf();\r\n  } else if (typeof first === 'object' && typeof second === typeof first) {\r\n    return areObjectsEqual(first, second);\r\n  } else {\r\n    return first === second;\r\n  }\r\n}\r\n\r\n/**\r\n * Performs a deep-clone of a provided object: such that the object is new (not\r\n * a reference) and all of its properties are likewise new.\r\n * @param  {any} obj\r\n */\r\nexport function cloneObject(obj: any): any {\r\n  let retObj: any;\r\n  if (!doesExist(obj)) {\r\n    return null;\r\n  } else if (Array.isArray(obj)) {\r\n    retObj = [];\r\n    obj.forEach((element) => retObj.push(cloneObject(element)));\r\n  } else if (typeof obj === 'object' && !(obj instanceof Date)) {\r\n    retObj = {};\r\n    Object.keys(obj).forEach((key) => (retObj[key] = cloneObject(obj[key])));\r\n  } else if (obj instanceof Date) {\r\n    retObj = new Date(obj.valueOf());\r\n  } else {\r\n    retObj = obj;\r\n  }\r\n  return retObj;\r\n}\r\n\r\n/**\r\n * For a provided object, replaces the object's properties with the corresponding\r\n * properties of a provided object argument.\r\n * @param  {any} arg?\r\n * @param  {any} obj?\r\n * @returns void\r\n */\r\nexport function constructInstance(arg?: any, obj?: any): void {\r\n  if (doesExist(arg) && doesExist(obj)) {\r\n    Object.keys(obj).forEach((key) => {\r\n      if (doesExist(arg[key])) {\r\n        obj[key] = arg[key];\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\n/**\r\n * For any object, iterate through properties and Object.freeze each.\r\n * @param  {any} obj\r\n */\r\nexport function deepFreeze(obj: any): void {\r\n  if (!doesExist(obj)) {\r\n    return;\r\n  } else if (Array.isArray(obj)) {\r\n    obj.forEach((element) => deepFreeze(element));\r\n  } else if (typeof obj === 'object' && !(obj instanceof Date)) {\r\n    Object.keys(obj).forEach((key) => deepFreeze(obj[key]));\r\n  }\r\n  Object.freeze(obj);\r\n}\r\n\r\n/**\r\n * Returns TRUE if the provided object is neither NULL nor UNDEFINED.\r\n * @param  {any} obj\r\n */\r\nexport function doesExist(obj: any): boolean {\r\n  return obj !== null && obj !== undefined;\r\n}\r\n\r\n/**\r\n * Returns whether or not the provided object is defined, but empty.\r\n * * An empty array is defined as an array with no entries\r\n * * An empty string is defined as a string with no characters\r\n * @param  {string|any[]} obj\r\n */\r\nexport function isEmpty(obj: string | any[]): boolean {\r\n  if (Array.isArray(obj)) {\r\n    return isArrayEmpty(obj);\r\n  } else if (typeof obj === 'object') {\r\n    return Object.keys(obj).length === 0;\r\n  } else {\r\n    return isStringEmpty(obj);\r\n  }\r\n}\r\n\r\n/**\r\n * Verifies that two objects have the same number of properties on their prototype\r\n * and then iterates through properties, verifying that the values assigned to each\r\n * property are likewise equivalent.\r\n * @param  {any} first\r\n * @param  {any} second\r\n */\r\nfunction areObjectsEqual(first: any, second: any): boolean {\r\n  const firstKeys = Object.keys(first);\r\n  let equal = firstKeys.length === Object.keys(second).length;\r\n  if (equal) {\r\n    equal = !firstKeys.some((key) => !areEqual(first[key], second[key]));\r\n  }\r\n  return equal;\r\n}\r\n\r\n/**\r\n * Verifies that two provided arrays both have the same number of elements and\r\n * that each element is equivalent to a corresponding element at the same index\r\n * in its provided sister array.\r\n * @param  {any[]} first\r\n * @param  {any[]} second\r\n */\r\nfunction areArraysEqual(first: any[], second: any[]): boolean {\r\n  let equal = first.length === second.length;\r\n  if (equal) {\r\n    equal = !first.some((val, idx) => !areEqual(val, second[idx]));\r\n  }\r\n  return equal;\r\n}\r\n\r\n/**\r\n * Returns TRUE if an array a is neither NULL nor UNDEFINED but contains\r\n * 0 entries within it.\r\n * @param  {any[]} a\r\n */\r\nfunction isArrayEmpty(a: any[]): boolean {\r\n  return doesExist(a) && a.length === 0;\r\n}\r\n\r\n/**\r\n * Returns TRUE if a string s is neither NULL nor UNDEFINED but does\r\n * have a length of 0.\r\n * @param  {string} s\r\n */\r\nfunction isStringEmpty(s: string): boolean {\r\n  return doesExist(s) && s.length === 0;\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}
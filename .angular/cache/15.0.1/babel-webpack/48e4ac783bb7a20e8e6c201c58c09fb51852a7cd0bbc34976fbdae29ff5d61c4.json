{"ast":null,"code":"import { BoundedRange } from '@shared/model/bounded-range.model';\nimport { areEqual, cloneObject, doesExist } from '@shared/utilities/common-util/common.util';\nimport { NestedMagicItemTable } from '@treasure/treasure-common/model/magic-item.model';\nimport { BehaviorSubject } from 'rxjs';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@shared/services/export/export.service\";\nexport class NestedMagicItemTableControllerService {\n  constructor(exportService) {\n    this.exportService = exportService;\n    this.nestedTableSource = new BehaviorSubject(new NestedMagicItemTable());\n    this.nestedTable$ = this.nestedTableSource.asObservable();\n  }\n  get nestedTable() {\n    return cloneObject(this.nestedTableSource.value);\n  }\n  set nestedTable(newTable) {\n    this.nestedTableSource.next(newTable);\n  }\n  addEntry(entry) {\n    const nextTable = this.nestedTable;\n    nextTable.entries.push(entry);\n    this.nestedTable = nextTable;\n  }\n  clear() {\n    this.nestedTable = new NestedMagicItemTable();\n  }\n  compareTable(table) {\n    const currentTable = this.nestedTable;\n    return doesExist(table) && table.name === currentTable.name && areEqual(table.entries, currentTable.entries);\n  }\n  exportTable() {\n    const exportTable = this.nestedTable;\n    this.exportService.exportAsJson(exportTable, doesExist(exportTable.name) && exportTable.name.length ? exportTable.name : 'Nested Magic Item Table');\n  }\n  importEntry(file) {\n    const fileReader = new FileReader();\n    fileReader.addEventListener('load', () => {\n      const result = fileReader.result;\n      const newEntry = JSON.parse(result);\n      this.addEntry({\n        chanceOf: new BoundedRange(),\n        entry: newEntry\n      });\n    });\n    fileReader.readAsText(file);\n  }\n  setTableName(name) {\n    this.nestedTable = Object.assign(Object.assign({}, this.nestedTable), {\n      name\n    });\n  }\n  removeEntryAt(index) {\n    const nextTable = this.nestedTable;\n    nextTable.entries.splice(index, 1);\n    this.nestedTable = nextTable;\n  }\n  updateTable(newTable) {\n    this.nestedTable = newTable;\n  }\n}\nNestedMagicItemTableControllerService.ɵfac = function NestedMagicItemTableControllerService_Factory(t) {\n  return new (t || NestedMagicItemTableControllerService)(i0.ɵɵinject(i1.ExportService));\n};\nNestedMagicItemTableControllerService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: NestedMagicItemTableControllerService,\n  factory: NestedMagicItemTableControllerService.ɵfac,\n  providedIn: 'root'\n});","map":{"version":3,"mappings":"AACA,SAASA,YAAY,QAAQ,mCAAmC;AAEhE,SACEC,QAAQ,EACRC,WAAW,EACXC,SAAS,QACJ,2CAA2C;AAClD,SACEC,oBAAoB,QAEf,kDAAkD;AACzD,SAASC,eAAe,QAAoB,MAAM;;;AAKlD,OAAM,MAAOC,qCAAqC;EAahDC,YAAoBC,aAA4B;IAA5B,kBAAa,GAAbA,aAAa;IAZzB,sBAAiB,GACvB,IAAIH,eAAe,CAAC,IAAID,oBAAoB,EAAE,CAAC;IAQjD,iBAAY,GACV,IAAI,CAACK,iBAAiB,CAACC,YAAY,EAAE;EAEY;EAVnD,IAAYC,WAAW;IACrB,OAAOT,WAAW,CAAC,IAAI,CAACO,iBAAiB,CAACG,KAAK,CAAC;EAClD;EACA,IAAYD,WAAW,CAACE,QAA8B;IACpD,IAAI,CAACJ,iBAAiB,CAACK,IAAI,CAACD,QAAQ,CAAC;EACvC;EAOAE,QAAQ,CAACC,KAAgC;IACvC,MAAMC,SAAS,GAAyB,IAAI,CAACN,WAAW;IACxDM,SAAS,CAACC,OAAO,CAACC,IAAI,CAACH,KAAK,CAAC;IAC7B,IAAI,CAACL,WAAW,GAAGM,SAAS;EAC9B;EAEAG,KAAK;IACH,IAAI,CAACT,WAAW,GAAG,IAAIP,oBAAoB,EAAE;EAC/C;EAEAiB,YAAY,CAACC,KAA2B;IACtC,MAAMC,YAAY,GAAG,IAAI,CAACZ,WAAW;IACrC,OACER,SAAS,CAACmB,KAAK,CAAC,IAChBA,KAAK,CAACE,IAAI,KAAKD,YAAY,CAACC,IAAI,IAChCvB,QAAQ,CAACqB,KAAK,CAACJ,OAAO,EAAEK,YAAY,CAACL,OAAO,CAAC;EAEjD;EAEAO,WAAW;IACT,MAAMA,WAAW,GAAyB,IAAI,CAACd,WAAW;IAC1D,IAAI,CAACH,aAAa,CAACkB,YAAY,CAC7BD,WAAW,EACXtB,SAAS,CAACsB,WAAW,CAACD,IAAI,CAAC,IAAIC,WAAW,CAACD,IAAI,CAACG,MAAM,GAClDF,WAAW,CAACD,IAAI,GAChB,yBAAyB,CAC9B;EACH;EAEAI,WAAW,CAACC,IAAU;IACpB,MAAMC,UAAU,GAAe,IAAIC,UAAU,EAAE;IAC/CD,UAAU,CAACE,gBAAgB,CAAC,MAAM,EAAE,MAAK;MACvC,MAAMC,MAAM,GAAWH,UAAU,CAACG,MAAgB;MAClD,MAAMC,QAAQ,GAAGC,IAAI,CAACC,KAAK,CAACH,MAAM,CAAC;MACnC,IAAI,CAAClB,QAAQ,CAAC;QACZsB,QAAQ,EAAE,IAAIrC,YAAY,EAAE;QAC5BgB,KAAK,EAAEkB;OACR,CAAC;IACJ,CAAC,CAAC;IACFJ,UAAU,CAACQ,UAAU,CAACT,IAAI,CAAC;EAC7B;EAEAU,YAAY,CAACf,IAAY;IACvB,IAAI,CAACb,WAAW,GAAG6B,gCACd,IAAI,CAAC7B,WAAW;MACnBa;IAAI,EACmB;EAC3B;EAEAiB,aAAa,CAACC,KAAa;IACzB,MAAMzB,SAAS,GAAyB,IAAI,CAACN,WAAW;IACxDM,SAAS,CAACC,OAAO,CAACyB,MAAM,CAACD,KAAK,EAAE,CAAC,CAAC;IAClC,IAAI,CAAC/B,WAAW,GAAGM,SAAS;EAC9B;EAEA2B,WAAW,CAAC/B,QAA8B;IACxC,IAAI,CAACF,WAAW,GAAGE,QAAQ;EAC7B;;;mBAxEWP,qCAAqC;AAAA;;SAArCA,qCAAqC;EAAAuC,SAArCvC,qCAAqC;EAAAwC,YAFpC;AAAM","names":["BoundedRange","areEqual","cloneObject","doesExist","NestedMagicItemTable","BehaviorSubject","NestedMagicItemTableControllerService","constructor","exportService","nestedTableSource","asObservable","nestedTable","value","newTable","next","addEntry","entry","nextTable","entries","push","clear","compareTable","table","currentTable","name","exportTable","exportAsJson","length","importEntry","file","fileReader","FileReader","addEventListener","result","newEntry","JSON","parse","chanceOf","readAsText","setTableName","Object","removeEntryAt","index","splice","updateTable","factory","providedIn"],"sourceRoot":"","sources":["D:\\workspaces\\greg\\src\\app\\treasure\\create-nested-magic-item-table\\services\\nested-magic-item-table-controller\\nested-magic-item-table-controller.service.ts"],"sourcesContent":["import { Injectable } from '@angular/core';\nimport { BoundedRange } from '@shared/model/bounded-range.model';\nimport { ExportService } from '@shared/services/export/export.service';\nimport {\n  areEqual,\n  cloneObject,\n  doesExist,\n} from '@shared/utilities/common-util/common.util';\nimport {\n  NestedMagicItemTable,\n  NestedMagicItemTableEntry,\n} from '@treasure/treasure-common/model/magic-item.model';\nimport { BehaviorSubject, Observable } from 'rxjs';\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class NestedMagicItemTableControllerService {\n  private nestedTableSource: BehaviorSubject<NestedMagicItemTable> =\n    new BehaviorSubject(new NestedMagicItemTable());\n  private get nestedTable(): NestedMagicItemTable {\n    return cloneObject(this.nestedTableSource.value);\n  }\n  private set nestedTable(newTable: NestedMagicItemTable) {\n    this.nestedTableSource.next(newTable);\n  }\n\n  nestedTable$: Observable<NestedMagicItemTable> =\n    this.nestedTableSource.asObservable();\n\n  constructor(private exportService: ExportService) {}\n\n  addEntry(entry: NestedMagicItemTableEntry): void {\n    const nextTable: NestedMagicItemTable = this.nestedTable;\n    nextTable.entries.push(entry);\n    this.nestedTable = nextTable;\n  }\n\n  clear(): void {\n    this.nestedTable = new NestedMagicItemTable();\n  }\n\n  compareTable(table: NestedMagicItemTable): boolean {\n    const currentTable = this.nestedTable;\n    return (\n      doesExist(table) &&\n      table.name === currentTable.name &&\n      areEqual(table.entries, currentTable.entries)\n    );\n  }\n\n  exportTable(): void {\n    const exportTable: NestedMagicItemTable = this.nestedTable;\n    this.exportService.exportAsJson(\n      exportTable,\n      doesExist(exportTable.name) && exportTable.name.length\n        ? exportTable.name\n        : 'Nested Magic Item Table'\n    );\n  }\n\n  importEntry(file: File): void {\n    const fileReader: FileReader = new FileReader();\n    fileReader.addEventListener('load', () => {\n      const result: string = fileReader.result as string;\n      const newEntry = JSON.parse(result);\n      this.addEntry({\n        chanceOf: new BoundedRange(),\n        entry: newEntry,\n      });\n    });\n    fileReader.readAsText(file);\n  }\n\n  setTableName(name: string): void {\n    this.nestedTable = {\n      ...this.nestedTable,\n      name,\n    } as NestedMagicItemTable;\n  }\n\n  removeEntryAt(index: number): void {\n    const nextTable: NestedMagicItemTable = this.nestedTable;\n    nextTable.entries.splice(index, 1);\n    this.nestedTable = nextTable;\n  }\n\n  updateTable(newTable: NestedMagicItemTable): void {\n    this.nestedTable = newTable;\n  }\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}
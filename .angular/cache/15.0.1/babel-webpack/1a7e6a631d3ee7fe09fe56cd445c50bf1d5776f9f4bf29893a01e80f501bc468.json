{"ast":null,"code":"import { DiceRolled } from '@shared/model/dice-rolled.model';\nimport { doesExist } from '@shared/utilities/common-util/common.util';\nimport { isWithinRange, rollDice } from '@shared/utilities/dice-roller/dice-roller.util';\nimport { MapsAndMagicResult } from '../model/treasure-maps-and-magic.model';\nexport function rollMapsAndMagic(mapsAndMagics) {\n  // loop through the maps and magic array\n  const result = [];\n  mapsAndMagics.forEach(entry => result.push(rollMapOrMagicEntry(entry)));\n  return result;\n}\nconst d100 = new DiceRolled({\n  pips: 100\n});\nfunction findTableToRollOn(table) {\n  const roll = rollDice(d100);\n  let targetEntry;\n  for (let tableEntry of table.entries) {\n    if (isWithinRange(roll, tableEntry.chanceOf)) {\n      targetEntry = tableEntry;\n      break;\n    }\n  }\n  // if the first result of the target entry's entries has entries, recusion!\n  const targetEntryTable = targetEntry.entry;\n  if (targetEntryTable.entries[0].entries) {\n    return findTableToRollOn(targetEntryTable);\n  } else {\n    return targetEntryTable;\n  }\n}\nfunction rollMapOrMagicEntry(mapOrMagic) {\n  // initialize a blank result\n  const result = new MapsAndMagicResult();\n  // Roll for item chance - returning blank if no item is found\n  if (rollDice(d100) > mapOrMagic.chanceOf) {\n    return result;\n  }\n  // Roll on the provided table a number of times equal to the \"numberOf\"\n  let mapOrMagicItem;\n  for (let i = 0; i < mapOrMagic.numberOf; i++) {\n    mapOrMagicItem = rollOnNestedMagicItemTable(mapOrMagic.entry);\n    if (doesExist(mapOrMagicItem.silver) || doesExist(mapOrMagicItem.gold) || doesExist(mapOrMagicItem.gems) || doesExist(mapOrMagicItem.jewelry)) {\n      result.treasureMaps.push(mapOrMagicItem);\n    } else if (doesExist(mapOrMagicItem.treasure)) {\n      result.magicMaps.push(mapOrMagicItem);\n    } else {\n      result.items.push(mapOrMagicItem);\n    }\n  }\n  // return the table\n  return result;\n}\nfunction rollOnNestedMagicItemTable(table) {\n  // find table to roll on, under the nesting\n  const targetTableEntry = findTableToRollOn(table);\n  // roll a chance of\n  const roll = rollDice(d100);\n  // find the result in the tableEntry\n  for (let resultItem of targetTableEntry.entries) {\n    if (isWithinRange(roll, resultItem.chanceOf)) {\n      if (resultItem.entry.entries) {\n        return rollEntries(resultItem.entry);\n      } else {\n        return resultItem.entry;\n      }\n    }\n  }\n  // if you've gotten to this point, the roll was out of bounds\n  throw new Error(`Roll result ${roll} on ${targetTableEntry.name} did not return an entry`);\n}\nfunction rollEntries(table) {\n  const roll = rollDice(d100);\n  for (let item of table.entries) {\n    if (isWithinRange(roll, item.chanceOf)) {\n      return item.entry;\n    }\n  }\n}","map":{"version":3,"mappings":"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","names":["DiceRolled","doesExist","isWithinRange","rollDice","MapsAndMagicResult","rollMapsAndMagic","mapsAndMagics","result","forEach","entry","push","rollMapOrMagicEntry","d100","pips","findTableToRollOn","table","roll","targetEntry","tableEntry","entries","chanceOf","targetEntryTable","mapOrMagic","mapOrMagicItem","i","numberOf","rollOnNestedMagicItemTable","silver","gold","gems","jewelry","treasureMaps","treasure","magicMaps","items","targetTableEntry","resultItem","rollEntries","Error","name","item"],"sourceRoot":"","sources":["D:\\workspaces\\greg\\src\\app\\treasure\\enter-treasure\\utilities\\map-and-magic-roller.util.ts"],"sourcesContent":["import { DiceRolled } from '@shared/model/dice-rolled.model';\r\nimport { doesExist } from '@shared/utilities/common-util/common.util';\r\nimport {\r\n  isWithinRange,\r\n  rollDice,\r\n} from '@shared/utilities/dice-roller/dice-roller.util';\r\nimport {\r\n  MagicItem,\r\n  MagicItemTable,\r\n  MagicItemTableEntry,\r\n  NestedMagicItemTable,\r\n  NestedMagicItemTableEntry,\r\n} from '@treasure/treasure-common/model/magic-item.model';\r\nimport {\r\n  MagicItemMap,\r\n  TreasureMap,\r\n} from '@treasure/treasure-common/model/treasure-map.model';\r\nimport { MapsAndMagicEntry } from '../model/treasure-list-entry.model';\r\nimport { MapsAndMagicResult } from '../model/treasure-maps-and-magic.model';\r\n\r\nexport function rollMapsAndMagic(\r\n  mapsAndMagics: MapsAndMagicEntry[]\r\n): MapsAndMagicResult[] {\r\n  // loop through the maps and magic array\r\n  const result: MapsAndMagicResult[] = [];\r\n  mapsAndMagics.forEach((entry) => result.push(rollMapOrMagicEntry(entry)));\r\n  return result;\r\n}\r\n\r\nconst d100: DiceRolled = new DiceRolled({ pips: 100 } as DiceRolled);\r\n\r\ntype MapOrMagicType = MagicItem | TreasureMap | MagicItemMap;\r\n\r\nfunction findTableToRollOn(\r\n  table: MagicItemTable | NestedMagicItemTable\r\n): MagicItemTable {\r\n  const roll: number = rollDice(d100);\r\n  let targetEntry: MagicItemTableEntry | NestedMagicItemTableEntry;\r\n  for (let tableEntry of table.entries) {\r\n    if (isWithinRange(roll, tableEntry.chanceOf)) {\r\n      targetEntry = tableEntry;\r\n      break;\r\n    }\r\n  }\r\n\r\n  // if the first result of the target entry's entries has entries, recusion!\r\n  const targetEntryTable: any = targetEntry.entry;\r\n  if (targetEntryTable.entries[0].entries) {\r\n    return findTableToRollOn(targetEntryTable);\r\n  } else {\r\n    return targetEntryTable;\r\n  }\r\n}\r\n\r\nfunction rollMapOrMagicEntry(\r\n  mapOrMagic: MapsAndMagicEntry\r\n): MapsAndMagicResult {\r\n  // initialize a blank result\r\n  const result: MapsAndMagicResult = new MapsAndMagicResult();\r\n\r\n  // Roll for item chance - returning blank if no item is found\r\n  if (rollDice(d100) > mapOrMagic.chanceOf) {\r\n    return result;\r\n  }\r\n\r\n  // Roll on the provided table a number of times equal to the \"numberOf\"\r\n  let mapOrMagicItem: MapOrMagicType;\r\n  for (let i = 0; i < mapOrMagic.numberOf; i++) {\r\n    mapOrMagicItem = rollOnNestedMagicItemTable(mapOrMagic.entry);\r\n    if (\r\n      doesExist((mapOrMagicItem as TreasureMap).silver) ||\r\n      doesExist((mapOrMagicItem as TreasureMap).gold) ||\r\n      doesExist((mapOrMagicItem as TreasureMap).gems) ||\r\n      doesExist((mapOrMagicItem as TreasureMap).jewelry)\r\n    ) {\r\n      result.treasureMaps.push(mapOrMagicItem as any);\r\n    } else if (doesExist((mapOrMagicItem as MagicItemMap).treasure)) {\r\n      result.magicMaps.push(mapOrMagicItem as any);\r\n    } else {\r\n      result.items.push(mapOrMagicItem as MagicItem);\r\n    }\r\n  }\r\n\r\n  // return the table\r\n  return result;\r\n}\r\n\r\nfunction rollOnNestedMagicItemTable(\r\n  table: MagicItemTable | NestedMagicItemTable\r\n): MapOrMagicType {\r\n  // find table to roll on, under the nesting\r\n  const targetTableEntry: MagicItemTable = findTableToRollOn(\r\n    table\r\n  ) as MagicItemTable;\r\n\r\n  // roll a chance of\r\n  const roll: number = rollDice(d100);\r\n\r\n  // find the result in the tableEntry\r\n  for (let resultItem of targetTableEntry.entries) {\r\n    if (isWithinRange(roll, resultItem.chanceOf)) {\r\n      if ((resultItem.entry as any).entries) {\r\n        return rollEntries(resultItem.entry as any);\r\n      } else {\r\n        return resultItem.entry;\r\n      }\r\n    }\r\n  }\r\n\r\n  // if you've gotten to this point, the roll was out of bounds\r\n  throw new Error(\r\n    `Roll result ${roll} on ${targetTableEntry.name} did not return an entry`\r\n  );\r\n}\r\n\r\nfunction rollEntries(table: MagicItemTable): MapOrMagicType {\r\n  const roll: number = rollDice(d100);\r\n  for (let item of table.entries) {\r\n    if (isWithinRange(roll, item.chanceOf)) {\r\n      return item.entry;\r\n    }\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}
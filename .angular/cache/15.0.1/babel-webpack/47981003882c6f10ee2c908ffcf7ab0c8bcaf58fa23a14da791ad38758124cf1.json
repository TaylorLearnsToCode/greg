{"ast":null,"code":"import { DiceRolled } from '@shared/model/dice-rolled.model';\nimport { doesExist } from '@shared/utilities/common-util/common.util';\nimport { isWithinRange, rollDice } from '@shared/utilities/dice-roller/dice-roller.util';\nimport { MapsAndMagicResult } from '../model/treasure-maps-and-magic.model';\nexport function rollMapsAndMagic(mapsAndMagics) {\n  // loop through the maps and magic array\n  const result = [];\n  mapsAndMagics.forEach(entry => result.push(rollMapOrMagicEntry(entry)));\n  return result;\n}\nconst d100 = new DiceRolled({\n  pips: 100\n});\nfunction findTableToRollOn(table) {\n  const roll = rollDice(d100);\n  let targetEntry;\n  for (let tableEntry of table.entries) {\n    if (isWithinRange(roll, tableEntry.chanceOf)) {\n      targetEntry = tableEntry;\n      break;\n    }\n  }\n  // if the first result of the target entry's entries has entries, recusion!\n  const targetEntryTable = targetEntry.entry;\n  if (targetEntryTable.entries[0].entries) {\n    return findTableToRollOn(targetEntryTable);\n  } else {\n    return targetEntryTable;\n  }\n}\nfunction rollMapOrMagicEntry(mapOrMagic) {\n  // initialize a blank result\n  const result = new MapsAndMagicResult();\n  // Roll for item chance - returning blank if no item is found\n  if (rollDice(d100) > mapOrMagic.chanceOf) {\n    return result;\n  }\n  // Roll on the provided table a number of times equal to the \"numberOf\"\n  let mapOrMagicItem;\n  for (let i = 0; i < mapOrMagic.numberOf; i++) {\n    mapOrMagicItem = rollOnNestedMagicItemTable(mapOrMagic.entry);\n    if (doesExist(mapOrMagicItem.description) && mapOrMagicItem.description === 'Treasure Map') {\n      result.treasureMaps.push(mapOrMagicItem);\n    } else if (doesExist(mapOrMagicItem.description) && mapOrMagicItem.description === 'Magic Item Map') {\n      result.magicMaps.push(mapOrMagicItem);\n    } else {\n      result.items.push(mapOrMagicItem);\n    }\n  }\n  // return the table\n  return result;\n}\nfunction rollOnNestedMagicItemTable(table) {\n  // find table to roll on, under the nesting\n  const targetTableEntry = findTableToRollOn(table);\n  // roll a chance of\n  const roll = rollDice(d100);\n  // find the result in the tableEntry\n  for (let resultItem of targetTableEntry.entries) {\n    if (isWithinRange(roll, resultItem.chanceOf)) {\n      return resultItem.entry;\n    }\n  }\n  // if you've gotten to this point, the roll was out of bounds\n  throw new Error(`Roll result ${roll} on ${targetTableEntry.name} did not return an entry`);\n}","map":{"version":3,"mappings":"AAAA,SAASA,UAAU,QAAQ,iCAAiC;AAC5D,SAASC,SAAS,QAAQ,2CAA2C;AACrE,SACEC,aAAa,EACbC,QAAQ,QACH,gDAAgD;AAavD,SAASC,kBAAkB,QAAQ,wCAAwC;AAE3E,OAAM,SAAUC,gBAAgB,CAC9BC,aAAkC;EAElC;EACA,MAAMC,MAAM,GAAyB,EAAE;EACvCD,aAAa,CAACE,OAAO,CAAEC,KAAK,IAAKF,MAAM,CAACG,IAAI,CAACC,mBAAmB,CAACF,KAAK,CAAC,CAAC,CAAC;EACzE,OAAOF,MAAM;AACf;AAEA,MAAMK,IAAI,GAAe,IAAIZ,UAAU,CAAC;EAAEa,IAAI,EAAE;AAAG,CAAgB,CAAC;AAIpE,SAASC,iBAAiB,CACxBC,KAA4C;EAE5C,MAAMC,IAAI,GAAWb,QAAQ,CAACS,IAAI,CAAC;EACnC,IAAIK,WAA4D;EAChE,KAAK,IAAIC,UAAU,IAAIH,KAAK,CAACI,OAAO,EAAE;IACpC,IAAIjB,aAAa,CAACc,IAAI,EAAEE,UAAU,CAACE,QAAQ,CAAC,EAAE;MAC5CH,WAAW,GAAGC,UAAU;MACxB;;;EAIJ;EACA,MAAMG,gBAAgB,GAAQJ,WAAW,CAACR,KAAK;EAC/C,IAAIY,gBAAgB,CAACF,OAAO,CAAC,CAAC,CAAC,CAACA,OAAO,EAAE;IACvC,OAAOL,iBAAiB,CAACO,gBAAgB,CAAC;GAC3C,MAAM;IACL,OAAOA,gBAAgB;;AAE3B;AAEA,SAASV,mBAAmB,CAC1BW,UAA6B;EAE7B;EACA,MAAMf,MAAM,GAAuB,IAAIH,kBAAkB,EAAE;EAE3D;EACA,IAAID,QAAQ,CAACS,IAAI,CAAC,GAAGU,UAAU,CAACF,QAAQ,EAAE;IACxC,OAAOb,MAAM;;EAGf;EACA,IAAIgB,cAA8B;EAClC,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,UAAU,CAACG,QAAQ,EAAED,CAAC,EAAE,EAAE;IAC5CD,cAAc,GAAGG,0BAA0B,CAACJ,UAAU,CAACb,KAAK,CAAC;IAC7D,IACER,SAAS,CAACsB,cAAc,CAACI,WAAW,CAAC,IACrCJ,cAAc,CAACI,WAAW,KAAK,cAAc,EAC7C;MACApB,MAAM,CAACqB,YAAY,CAAClB,IAAI,CAACa,cAA6B,CAAC;KACxD,MAAM,IACLtB,SAAS,CAACsB,cAAc,CAACI,WAAW,CAAC,IACrCJ,cAAc,CAACI,WAAW,KAAK,gBAAgB,EAC/C;MACApB,MAAM,CAACsB,SAAS,CAACnB,IAAI,CAACa,cAA8B,CAAC;KACtD,MAAM;MACLhB,MAAM,CAACuB,KAAK,CAACpB,IAAI,CAACa,cAA2B,CAAC;;;EAIlD;EACA,OAAOhB,MAAM;AACf;AAEA,SAASmB,0BAA0B,CACjCX,KAA4C;EAE5C;EACA,MAAMgB,gBAAgB,GAAmBjB,iBAAiB,CACxDC,KAAK,CACY;EAEnB;EACA,MAAMC,IAAI,GAAWb,QAAQ,CAACS,IAAI,CAAC;EAEnC;EACA,KAAK,IAAIoB,UAAU,IAAID,gBAAgB,CAACZ,OAAO,EAAE;IAC/C,IAAIjB,aAAa,CAACc,IAAI,EAAEgB,UAAU,CAACZ,QAAQ,CAAC,EAAE;MAC5C,OAAOY,UAAU,CAACvB,KAAK;;;EAI3B;EACA,MAAM,IAAIwB,KAAK,CACb,eAAejB,IAAI,OAAOe,gBAAgB,CAACG,IAAI,0BAA0B,CAC1E;AACH","names":["DiceRolled","doesExist","isWithinRange","rollDice","MapsAndMagicResult","rollMapsAndMagic","mapsAndMagics","result","forEach","entry","push","rollMapOrMagicEntry","d100","pips","findTableToRollOn","table","roll","targetEntry","tableEntry","entries","chanceOf","targetEntryTable","mapOrMagic","mapOrMagicItem","i","numberOf","rollOnNestedMagicItemTable","description","treasureMaps","magicMaps","items","targetTableEntry","resultItem","Error","name"],"sourceRoot":"","sources":["D:\\workspaces\\greg\\src\\app\\treasure\\enter-treasure\\utilities\\map-and-magic-roller.util.ts"],"sourcesContent":["import { DiceRolled } from '@shared/model/dice-rolled.model';\r\nimport { doesExist } from '@shared/utilities/common-util/common.util';\r\nimport {\r\n  isWithinRange,\r\n  rollDice,\r\n} from '@shared/utilities/dice-roller/dice-roller.util';\r\nimport {\r\n  MagicItem,\r\n  MagicItemTable,\r\n  MagicItemTableEntry,\r\n  NestedMagicItemTable,\r\n  NestedMagicItemTableEntry,\r\n} from '@treasure/treasure-common/model/magic-item.model';\r\nimport {\r\n  MagicItemMap,\r\n  TreasureMap,\r\n} from '@treasure/treasure-common/model/treasure-map.model';\r\nimport { MapsAndMagicEntry } from '../model/treasure-list-entry.model';\r\nimport { MapsAndMagicResult } from '../model/treasure-maps-and-magic.model';\r\n\r\nexport function rollMapsAndMagic(\r\n  mapsAndMagics: MapsAndMagicEntry[]\r\n): MapsAndMagicResult[] {\r\n  // loop through the maps and magic array\r\n  const result: MapsAndMagicResult[] = [];\r\n  mapsAndMagics.forEach((entry) => result.push(rollMapOrMagicEntry(entry)));\r\n  return result;\r\n}\r\n\r\nconst d100: DiceRolled = new DiceRolled({ pips: 100 } as DiceRolled);\r\n\r\ntype MapOrMagicType = MagicItem | TreasureMap | MagicItemMap;\r\n\r\nfunction findTableToRollOn(\r\n  table: MagicItemTable | NestedMagicItemTable\r\n): MagicItemTable {\r\n  const roll: number = rollDice(d100);\r\n  let targetEntry: MagicItemTableEntry | NestedMagicItemTableEntry;\r\n  for (let tableEntry of table.entries) {\r\n    if (isWithinRange(roll, tableEntry.chanceOf)) {\r\n      targetEntry = tableEntry;\r\n      break;\r\n    }\r\n  }\r\n\r\n  // if the first result of the target entry's entries has entries, recusion!\r\n  const targetEntryTable: any = targetEntry.entry;\r\n  if (targetEntryTable.entries[0].entries) {\r\n    return findTableToRollOn(targetEntryTable);\r\n  } else {\r\n    return targetEntryTable;\r\n  }\r\n}\r\n\r\nfunction rollMapOrMagicEntry(\r\n  mapOrMagic: MapsAndMagicEntry\r\n): MapsAndMagicResult {\r\n  // initialize a blank result\r\n  const result: MapsAndMagicResult = new MapsAndMagicResult();\r\n\r\n  // Roll for item chance - returning blank if no item is found\r\n  if (rollDice(d100) > mapOrMagic.chanceOf) {\r\n    return result;\r\n  }\r\n\r\n  // Roll on the provided table a number of times equal to the \"numberOf\"\r\n  let mapOrMagicItem: MapOrMagicType;\r\n  for (let i = 0; i < mapOrMagic.numberOf; i++) {\r\n    mapOrMagicItem = rollOnNestedMagicItemTable(mapOrMagic.entry);\r\n    if (\r\n      doesExist(mapOrMagicItem.description) &&\r\n      mapOrMagicItem.description === 'Treasure Map'\r\n    ) {\r\n      result.treasureMaps.push(mapOrMagicItem as TreasureMap);\r\n    } else if (\r\n      doesExist(mapOrMagicItem.description) &&\r\n      mapOrMagicItem.description === 'Magic Item Map'\r\n    ) {\r\n      result.magicMaps.push(mapOrMagicItem as MagicItemMap);\r\n    } else {\r\n      result.items.push(mapOrMagicItem as MagicItem);\r\n    }\r\n  }\r\n\r\n  // return the table\r\n  return result;\r\n}\r\n\r\nfunction rollOnNestedMagicItemTable(\r\n  table: MagicItemTable | NestedMagicItemTable\r\n): MapOrMagicType {\r\n  // find table to roll on, under the nesting\r\n  const targetTableEntry: MagicItemTable = findTableToRollOn(\r\n    table\r\n  ) as MagicItemTable;\r\n\r\n  // roll a chance of\r\n  const roll: number = rollDice(d100);\r\n\r\n  // find the result in the tableEntry\r\n  for (let resultItem of targetTableEntry.entries) {\r\n    if (isWithinRange(roll, resultItem.chanceOf)) {\r\n      return resultItem.entry;\r\n    }\r\n  }\r\n\r\n  // if you've gotten to this point, the roll was out of bounds\r\n  throw new Error(\r\n    `Roll result ${roll} on ${targetTableEntry.name} did not return an entry`\r\n  );\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}
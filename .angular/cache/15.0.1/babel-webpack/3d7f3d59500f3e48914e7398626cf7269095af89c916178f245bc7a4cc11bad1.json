{"ast":null,"code":"import { CreateEncounterTableAction } from '@encounter/create-encounter-table/model/create-encounter-table-action.enum';\nimport { EncounterTableType } from '@encounter/encounter-shared/model/encounter-table-types.enum';\nimport { EncounterTable } from '@encounter/encounter-shared/model/encounter-table.model';\nimport { BoundedRange } from '@shared/model/bounded-range.model';\nimport { DiceRolled } from '@shared/model/dice-rolled.model';\nimport { cloneObject, deepFreeze, doesExist, isEmpty } from '@shared/utilities/common-util/common.util';\nimport { getRollRange } from '@shared/utilities/dice-roller/dice-roller.util';\nimport { BehaviorSubject, Subject } from 'rxjs';\nimport { takeUntil } from 'rxjs/operators';\nimport * as i0 from \"@angular/core\";\nexport class CreateEncounterTableFacadeService {\n  constructor() {\n    this.diceRolledSource = new BehaviorSubject(null);\n    this.destroySource = new Subject();\n    this.encounterRollMappingSource = new BehaviorSubject(null);\n    this.encountersSource = new BehaviorSubject(null);\n    this.locationSource = new BehaviorSubject(null);\n    this.nameSource = new BehaviorSubject(null);\n    this.typeSource = new BehaviorSubject(null);\n  }\n  get diceRolled() {\n    return [...this.diceRolledSource.value.map(dice => new DiceRolled(dice))];\n  }\n  set diceRolled(dice) {\n    deepFreeze(dice);\n    this.diceRolledSource.next(dice);\n  }\n  get encounterRollMapping() {\n    return cloneObject(this.encounterRollMappingSource.value);\n  }\n  set encounterRollMapping(newMapping) {\n    deepFreeze(newMapping);\n    this.encounterRollMappingSource.next(newMapping);\n  }\n  get encounters() {\n    return cloneObject(this.encountersSource.value);\n  }\n  set encounters(newEncounters) {\n    deepFreeze(newEncounters);\n    this.encountersSource.next(newEncounters);\n  }\n  get location() {\n    return cloneObject(this.locationSource.value);\n  }\n  set location(newLocation) {\n    deepFreeze(newLocation);\n    this.locationSource.next(newLocation);\n  }\n  get name() {\n    return this.nameSource.value;\n  }\n  set name(newName) {\n    this.nameSource.next(newName);\n  }\n  get type() {\n    return cloneObject(this.typeSource.value);\n  }\n  set type(newType) {\n    deepFreeze(newType);\n    this.typeSource.next(newType);\n  }\n  destroy() {\n    this.destroySource.next();\n  }\n  handleCreateEnounterTableAction(action) {\n    switch (action.action) {\n      case CreateEncounterTableAction.INFER_ENCOUNTERS:\n        {\n          this.inferEncounterTable();\n          break;\n        }\n      case CreateEncounterTableAction.SAVE_CONFIG:\n        {\n          this.onSaveConfig(action.payload);\n          break;\n        }\n      case CreateEncounterTableAction.SAVE_DICE_ROLLED:\n        {\n          this.diceRolled = action.payload;\n          break;\n        }\n      case CreateEncounterTableAction.SAVE_ENCOUNTERS:\n        {\n          this.onSaveEncounters(action.payload);\n          break;\n        }\n      default:\n        {\n          break;\n        }\n    }\n  }\n  initialize() {\n    this.initializeSources();\n    this.initializeStreams();\n    return true;\n  }\n  /** @todo Clean Up! */\n  inferEncounterTable() {\n    const diceRolled = this.diceRolled;\n    const encounters = this.encounters;\n    const mapping = this.encounterRollMapping;\n    const type = this.type;\n    let rollMappingRange;\n    if (!doesExist(diceRolled) || isEmpty(diceRolled)) {\n      throw Error('DiceRolled is empty');\n    }\n    if (!doesExist(type) || type == EncounterTableType.UNSPECIFIED) {\n      throw Error('Unable to infer table structure with UNSPECIFIED type');\n    }\n    if (type == EncounterTableType.NESTED) {\n      alert('nested');\n    } else if (type == EncounterTableType.STANDARD) {\n      rollMappingRange = getRollRange(...diceRolled);\n      let index;\n      while (mapping.length < rollMappingRange.length) {\n        index = mapping.length;\n        mapping.push({\n          index,\n          roll: new BoundedRange({\n            low: index + 1\n          })\n        });\n      }\n      while (encounters.length < mapping.length) {\n        encounters.push({});\n      }\n      this.encounters = encounters;\n      this.encounterRollMapping = mapping;\n    } else {\n      throw Error(`Unspecified type ${type} detected`);\n    }\n  }\n  initializeSources() {\n    const table = new EncounterTable();\n    deepFreeze(table);\n    this.diceRolled = table.diceRolled;\n    this.encounterRollMapping = table.encounterRollMapping;\n    this.encounters = table.encounters;\n    this.location = table.location;\n    this.name = table.name;\n    this.type = EncounterTableType.UNSPECIFIED;\n  }\n  initializeStreams() {\n    this.diceRolled$ = this.diceRolledSource.asObservable().pipe(takeUntil(this.destroySource));\n    this.encounterRollMapping$ = this.encounterRollMappingSource.asObservable().pipe(takeUntil(this.destroySource));\n    this.encounters$ = this.encountersSource.asObservable().pipe(takeUntil(this.destroySource));\n    this.location$ = this.locationSource.asObservable().pipe(takeUntil(this.destroySource));\n    this.name$ = this.nameSource.asObservable().pipe(takeUntil(this.destroySource));\n    this.type$ = this.typeSource.asObservable().pipe(takeUntil(this.destroySource));\n  }\n  onSaveConfig(config) {\n    this.location = config.location;\n    this.name = config.name;\n    this.type = config.type;\n  }\n  onSaveEncounters(table) {\n    this.encounters = table.encounters;\n    this.encounterRollMapping = table.encounterRollMapping;\n  }\n}\nCreateEncounterTableFacadeService.ɵfac = function CreateEncounterTableFacadeService_Factory(t) {\n  return new (t || CreateEncounterTableFacadeService)();\n};\nCreateEncounterTableFacadeService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: CreateEncounterTableFacadeService,\n  factory: CreateEncounterTableFacadeService.ɵfac,\n  providedIn: 'root'\n});","map":{"version":3,"mappings":"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","names":["CreateEncounterTableAction","EncounterTableType","EncounterTable","BoundedRange","DiceRolled","cloneObject","deepFreeze","doesExist","isEmpty","getRollRange","BehaviorSubject","Subject","takeUntil","CreateEncounterTableFacadeService","constructor","diceRolled","diceRolledSource","value","map","dice","next","encounterRollMapping","encounterRollMappingSource","newMapping","encounters","encountersSource","newEncounters","location","locationSource","newLocation","name","nameSource","newName","type","typeSource","newType","destroy","destroySource","handleCreateEnounterTableAction","action","INFER_ENCOUNTERS","inferEncounterTable","SAVE_CONFIG","onSaveConfig","payload","SAVE_DICE_ROLLED","SAVE_ENCOUNTERS","onSaveEncounters","initialize","initializeSources","initializeStreams","mapping","rollMappingRange","Error","UNSPECIFIED","NESTED","alert","STANDARD","index","length","push","roll","low","table","diceRolled$","asObservable","pipe","encounterRollMapping$","encounters$","location$","name$","type$","config","factory","providedIn"],"sourceRoot":"","sources":["D:\\workspaces\\greg\\src\\app\\encounter\\create-encounter-table\\services\\create-encounter-table-facade\\create-encounter-table-facade.service.ts"],"sourcesContent":["import { Injectable } from '@angular/core';\r\nimport { CreateEncounterTableAction } from '@encounter/create-encounter-table/model/create-encounter-table-action.enum';\r\nimport { ICreateEncounterTableAction } from '@encounter/create-encounter-table/model/create-encounter-table-action.interface';\r\nimport { IUpdateConfigDto } from '@encounter/create-encounter-table/model/update-config-dto.interface';\r\nimport { EncounterLocation } from '@encounter/encounter-shared/model/encounter-locationS.enum';\r\nimport { EncounterTableType } from '@encounter/encounter-shared/model/encounter-table-types.enum';\r\nimport { EncounterTable } from '@encounter/encounter-shared/model/encounter-table.model';\r\nimport { Encounter } from '@encounter/encounter-shared/model/encounter.model';\r\nimport { BoundedRange } from '@shared/model/bounded-range.model';\r\nimport { DiceRolled } from '@shared/model/dice-rolled.model';\r\nimport { IRollMapping } from '@shared/model/roll-index-mapping.interface';\r\nimport {\r\n  cloneObject,\r\n  deepFreeze,\r\n  doesExist,\r\n  isEmpty,\r\n} from '@shared/utilities/common-util/common.util';\r\nimport { getRollRange } from '@shared/utilities/dice-roller/dice-roller.util';\r\nimport { BehaviorSubject, Observable, Subject } from 'rxjs';\r\nimport { takeUntil } from 'rxjs/operators';\r\n\r\n@Injectable({\r\n  providedIn: 'root',\r\n})\r\nexport class CreateEncounterTableFacadeService {\r\n  private get diceRolled(): DiceRolled[] {\r\n    return [...this.diceRolledSource.value.map((dice) => new DiceRolled(dice))];\r\n  }\r\n  private set diceRolled(dice: DiceRolled[]) {\r\n    deepFreeze(dice);\r\n    this.diceRolledSource.next(dice);\r\n  }\r\n  private diceRolledSource = new BehaviorSubject<DiceRolled[]>(null);\r\n  private destroySource = new Subject<void>();\r\n  private get encounterRollMapping(): IRollMapping[] {\r\n    return cloneObject(this.encounterRollMappingSource.value);\r\n  }\r\n  private set encounterRollMapping(newMapping: IRollMapping[]) {\r\n    deepFreeze(newMapping);\r\n    this.encounterRollMappingSource.next(newMapping);\r\n  }\r\n  private encounterRollMappingSource = new BehaviorSubject<IRollMapping[]>(\r\n    null\r\n  );\r\n  private get encounters(): Array<Encounter | EncounterTable> {\r\n    return cloneObject(this.encountersSource.value);\r\n  }\r\n  private set encounters(newEncounters: Array<Encounter | EncounterTable>) {\r\n    deepFreeze(newEncounters);\r\n    this.encountersSource.next(newEncounters);\r\n  }\r\n  private encountersSource = new BehaviorSubject<\r\n    Array<Encounter | EncounterTable>\r\n  >(null);\r\n  private get location(): EncounterLocation {\r\n    return cloneObject(this.locationSource.value) as EncounterLocation;\r\n  }\r\n  private set location(newLocation: EncounterLocation) {\r\n    deepFreeze(newLocation);\r\n    this.locationSource.next(newLocation);\r\n  }\r\n  private locationSource = new BehaviorSubject<EncounterLocation>(null);\r\n  private get name(): string {\r\n    return this.nameSource.value;\r\n  }\r\n  private set name(newName: string) {\r\n    this.nameSource.next(newName);\r\n  }\r\n  private nameSource = new BehaviorSubject<string>(null);\r\n  private get type(): EncounterTableType {\r\n    return cloneObject(this.typeSource.value);\r\n  }\r\n  private set type(newType: EncounterTableType) {\r\n    deepFreeze(newType);\r\n    this.typeSource.next(newType);\r\n  }\r\n  private typeSource = new BehaviorSubject<EncounterTableType>(null);\r\n\r\n  diceRolled$: Observable<DiceRolled[]>;\r\n  encounterRollMapping$: Observable<IRollMapping[]>;\r\n  encounters$: Observable<Array<Encounter | EncounterTable>>;\r\n  location$: Observable<EncounterLocation>;\r\n  name$: Observable<string>;\r\n  type$: Observable<EncounterTableType>;\r\n\r\n  constructor() {}\r\n\r\n  destroy(): void {\r\n    this.destroySource.next();\r\n  }\r\n\r\n  handleCreateEnounterTableAction(action: ICreateEncounterTableAction): void {\r\n    switch (action.action) {\r\n      case CreateEncounterTableAction.INFER_ENCOUNTERS: {\r\n        this.inferEncounterTable();\r\n        break;\r\n      }\r\n      case CreateEncounterTableAction.SAVE_CONFIG: {\r\n        this.onSaveConfig(action.payload);\r\n        break;\r\n      }\r\n      case CreateEncounterTableAction.SAVE_DICE_ROLLED: {\r\n        this.diceRolled = action.payload;\r\n        break;\r\n      }\r\n      case CreateEncounterTableAction.SAVE_ENCOUNTERS: {\r\n        this.onSaveEncounters(action.payload);\r\n        break;\r\n      }\r\n      default: {\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  initialize(): boolean {\r\n    this.initializeSources();\r\n    this.initializeStreams();\r\n    return true;\r\n  }\r\n\r\n  /** @todo Clean Up! */\r\n  private inferEncounterTable(): void {\r\n    const diceRolled: DiceRolled[] = this.diceRolled;\r\n    const encounters: Array<Encounter | EncounterTable> = this.encounters;\r\n    const mapping: IRollMapping[] = this.encounterRollMapping;\r\n    const type = this.type;\r\n    let rollMappingRange: number[];\r\n\r\n    if (!doesExist(diceRolled) || isEmpty(diceRolled)) {\r\n      throw Error('DiceRolled is empty');\r\n    }\r\n\r\n    if (!doesExist(type) || type == EncounterTableType.UNSPECIFIED) {\r\n      throw Error('Unable to infer table structure with UNSPECIFIED type');\r\n    }\r\n\r\n    if (type == EncounterTableType.NESTED) {\r\n      alert('nested');\r\n    } else if (type == EncounterTableType.STANDARD) {\r\n      rollMappingRange = getRollRange(...diceRolled);\r\n      let index: number;\r\n      while (mapping.length < rollMappingRange.length) {\r\n        index = mapping.length;\r\n        mapping.push({\r\n          index,\r\n          roll: new BoundedRange({\r\n            low: index + 1,\r\n          } as BoundedRange),\r\n        } as IRollMapping);\r\n      }\r\n      while (encounters.length < mapping.length) {\r\n        encounters.push({} as EncounterTable);\r\n      }\r\n      this.encounters = encounters;\r\n      this.encounterRollMapping = mapping;\r\n    } else {\r\n      throw Error(`Unspecified type ${type} detected`);\r\n    }\r\n  }\r\n\r\n  private initializeSources(): void {\r\n    const table = new EncounterTable();\r\n    deepFreeze(table);\r\n    this.diceRolled = table.diceRolled;\r\n    this.encounterRollMapping = table.encounterRollMapping;\r\n    this.encounters = table.encounters;\r\n    this.location = table.location;\r\n    this.name = table.name;\r\n    this.type = EncounterTableType.UNSPECIFIED;\r\n  }\r\n\r\n  private initializeStreams(): void {\r\n    this.diceRolled$ = this.diceRolledSource\r\n      .asObservable()\r\n      .pipe(takeUntil(this.destroySource));\r\n    this.encounterRollMapping$ = this.encounterRollMappingSource\r\n      .asObservable()\r\n      .pipe(takeUntil(this.destroySource));\r\n    this.encounters$ = this.encountersSource\r\n      .asObservable()\r\n      .pipe(takeUntil(this.destroySource));\r\n    this.location$ = this.locationSource\r\n      .asObservable()\r\n      .pipe(takeUntil(this.destroySource));\r\n    this.name$ = this.nameSource\r\n      .asObservable()\r\n      .pipe(takeUntil(this.destroySource));\r\n    this.type$ = this.typeSource\r\n      .asObservable()\r\n      .pipe(takeUntil(this.destroySource));\r\n  }\r\n\r\n  private onSaveConfig(config: IUpdateConfigDto): void {\r\n    this.location = config.location;\r\n    this.name = config.name;\r\n    this.type = config.type;\r\n  }\r\n\r\n  private onSaveEncounters(table: EncounterTable): void {\r\n    this.encounters = table.encounters;\r\n    this.encounterRollMapping = table.encounterRollMapping;\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}
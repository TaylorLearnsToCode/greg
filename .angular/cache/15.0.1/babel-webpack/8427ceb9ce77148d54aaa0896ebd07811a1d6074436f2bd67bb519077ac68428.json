{"ast":null,"code":"import { BoundedRange } from '@shared/model/bounded-range.model';\nimport { DiceRolled } from '../../model/dice-rolled.model';\n/**\r\n * For a collection of provided dice pools, provides the minimum and maximum possible\r\n * results in the form of a two-element array.\r\n * @param  {DiceRolled[]} ...dice\r\n */\nexport function getBoundedRange(...dicePools) {\n  let min = 0;\n  let max = 0;\n  dicePools.forEach(pool => {\n    min += (pool.modifier + pool.no) * pool.multiplier;\n    max += (pool.modifier + pool.pips * pool.no) * pool.multiplier;\n  });\n  return new BoundedRange({\n    low: min,\n    high: max\n  });\n}\n/**\r\n * For a collection of provided dice pools, provides the full range of possible\r\n * results of those dice pools in an ascending numeric array.\r\n * @param  {DiceRolled[]} ...dice\r\n */\nexport function getRollRange(...dicePools) {\n  const result = [];\n  const [min, max] = getBoundedRange(...dicePools).range;\n  for (let i = min; i <= max; i++) {\n    result.push(i);\n  }\n  return result;\n}\n/**\r\n * Master function for overloaded rollDice methods, supporting the following\r\n * argument configurations:\r\n * * no, pips, modifier, multiplier\r\n * * DiceRolled\r\n * * DiceRolled[]\r\n * @param  {any[]} ...dice\r\n */\nexport function rollDice(...dice) {\n  let result = 0;\n  if (dice[0] instanceof DiceRolled || Array.isArray(dice)) {\n    dice.forEach(die => {\n      if (Array.isArray(die)) {\n        die.forEach(subDie => result += rollDice(subDie));\n      } else {\n        for (let i = 0; i < die.no; i++) {\n          result += die.multiplier * (rollOneDie(die) + die.modifier);\n        }\n      }\n    });\n  } else {\n    const {\n      no,\n      pips,\n      modifier,\n      multiplier\n    } = dice;\n    result += rollDice(new DiceRolled({\n      no,\n      pips,\n      modifier,\n      multiplier\n    }));\n  }\n  return result;\n}\n/**\r\n * For a provided DiceRolled, generates a random number bounded by 1 and the\r\n * number of pips specified, with even probability between each possible result.\r\n * @param  {DiceRolled} die\r\n */\nfunction rollOneDie(die) {\n  return Math.floor(Math.random() * die.pips) + 1;\n}","map":{"version":3,"mappings":"AAAA,SAASA,YAAY,QAAQ,mCAAmC;AAChE,SAASC,UAAU,QAAQ,+BAA+B;AAE1D;;;;;AAKA,OAAM,SAAUC,eAAe,CAAC,GAAGC,SAAuB;EACxD,IAAIC,GAAG,GAAG,CAAC;EACX,IAAIC,GAAG,GAAG,CAAC;EACXF,SAAS,CAACG,OAAO,CAAEC,IAAI,IAAI;IACzBH,GAAG,IAAI,CAACG,IAAI,CAACC,QAAQ,GAAGD,IAAI,CAACE,EAAE,IAAIF,IAAI,CAACG,UAAU;IAClDL,GAAG,IAAI,CAACE,IAAI,CAACC,QAAQ,GAAGD,IAAI,CAACI,IAAI,GAAGJ,IAAI,CAACE,EAAE,IAAIF,IAAI,CAACG,UAAU;EAChE,CAAC,CAAC;EACF,OAAO,IAAIV,YAAY,CAAC;IACtBY,GAAG,EAAER,GAAG;IACRS,IAAI,EAAER;GACS,CAAC;AACpB;AAEA;;;;;AAKA,OAAM,SAAUS,YAAY,CAAC,GAAGX,SAAuB;EACrD,MAAMY,MAAM,GAAa,EAAE;EAC3B,MAAM,CAACX,GAAG,EAAEC,GAAG,CAAC,GAAGH,eAAe,CAAC,GAAGC,SAAS,CAAC,CAACa,KAAK;EACtD,KAAK,IAAIC,CAAC,GAAGb,GAAG,EAAEa,CAAC,IAAIZ,GAAG,EAAEY,CAAC,EAAE,EAAE;IAC/BF,MAAM,CAACG,IAAI,CAACD,CAAC,CAAC;;EAEhB,OAAOF,MAAM;AACf;AAyBA;;;;;;;;AAQA,OAAM,SAAUI,QAAQ,CAAC,GAAGC,IAAW;EACrC,IAAIL,MAAM,GAAG,CAAC;EACd,IAAIK,IAAI,CAAC,CAAC,CAAC,YAAYnB,UAAU,IAAIoB,KAAK,CAACC,OAAO,CAACF,IAAI,CAAC,EAAE;IACxDA,IAAI,CAACd,OAAO,CAAEiB,GAAG,IAAI;MACnB,IAAIF,KAAK,CAACC,OAAO,CAACC,GAAG,CAAC,EAAE;QACtBA,GAAG,CAACjB,OAAO,CAAEkB,MAAM,IAAMT,MAAM,IAAII,QAAQ,CAACK,MAAM,CAAE,CAAC;OACtD,MAAM;QACL,KAAK,IAAIP,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGM,GAAG,CAACd,EAAE,EAAEQ,CAAC,EAAE,EAAE;UAC/BF,MAAM,IAAIQ,GAAG,CAACb,UAAU,IAAIe,UAAU,CAACF,GAAG,CAAC,GAAGA,GAAG,CAACf,QAAQ,CAAC;;;IAGjE,CAAC,CAAC;GACH,MAAM;IACL,MAAM;MAAEC,EAAE;MAAEE,IAAI;MAAEH,QAAQ;MAAEE;IAAU,CAAE,GAAGU,IAAI;IAC/CL,MAAM,IAAII,QAAQ,CAChB,IAAIlB,UAAU,CAAC;MAAEQ,EAAE;MAAEE,IAAI;MAAEH,QAAQ;MAAEE;IAAU,CAAgB,CAAC,CACjE;;EAEH,OAAOK,MAAM;AACf;AAEA;;;;;AAKA,SAASU,UAAU,CAACF,GAAe;EACjC,OAAOG,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,MAAM,EAAE,GAAGL,GAAG,CAACZ,IAAI,CAAC,GAAG,CAAC;AACjD","names":["BoundedRange","DiceRolled","getBoundedRange","dicePools","min","max","forEach","pool","modifier","no","multiplier","pips","low","high","getRollRange","result","range","i","push","rollDice","dice","Array","isArray","die","subDie","rollOneDie","Math","floor","random"],"sourceRoot":"","sources":["D:\\workspaces\\greg\\src\\app\\shared\\utilities\\dice-roller\\dice-roller.util.ts"],"sourcesContent":["import { BoundedRange } from '@shared/model/bounded-range.model';\r\nimport { DiceRolled } from '../../model/dice-rolled.model';\r\n\r\n/**\r\n * For a collection of provided dice pools, provides the minimum and maximum possible\r\n * results in the form of a two-element array.\r\n * @param  {DiceRolled[]} ...dice\r\n */\r\nexport function getBoundedRange(...dicePools: DiceRolled[]): BoundedRange {\r\n  let min = 0;\r\n  let max = 0;\r\n  dicePools.forEach((pool) => {\r\n    min += (pool.modifier + pool.no) * pool.multiplier;\r\n    max += (pool.modifier + pool.pips * pool.no) * pool.multiplier;\r\n  });\r\n  return new BoundedRange({\r\n    low: min,\r\n    high: max,\r\n  } as BoundedRange);\r\n}\r\n\r\n/**\r\n * For a collection of provided dice pools, provides the full range of possible\r\n * results of those dice pools in an ascending numeric array.\r\n * @param  {DiceRolled[]} ...dice\r\n */\r\nexport function getRollRange(...dicePools: DiceRolled[]): number[] {\r\n  const result: number[] = [];\r\n  const [min, max] = getBoundedRange(...dicePools).range;\r\n  for (let i = min; i <= max; i++) {\r\n    result.push(i);\r\n  }\r\n  return result;\r\n}\r\n\r\n/**\r\n * Rolls {no} number of dice, each with {pips} faces, and returns the result.\r\n * * If a {modifier} is provided, the modifier is added to the result.\r\n * * If a {multiplier} is provided, the result (including modifier) is\r\n * multiplied by that multiplier.\r\n * @param  {number} no\r\n * @param  {number} pips\r\n * @param  {number} modifier?\r\n * @param  {number} multiplier?\r\n */\r\nexport function rollDice(\r\n  no: number,\r\n  pips: number,\r\n  modifier?: number,\r\n  multiplier?: number\r\n): number;\r\n/**\r\n * Rolls a provided DiceRolled or collection of DiceRolled and returns the result.\r\n * Multipliers are calculated <i>after</i> modifiers: thus, 1d6+1, multiplied by 3,\r\n * becomes 3d6+3.\r\n * @param  {DiceRolled|DiceRolled[]} dice\r\n */\r\nexport function rollDice(dice: DiceRolled | DiceRolled[]): number;\r\n/**\r\n * Master function for overloaded rollDice methods, supporting the following\r\n * argument configurations:\r\n * * no, pips, modifier, multiplier\r\n * * DiceRolled\r\n * * DiceRolled[]\r\n * @param  {any[]} ...dice\r\n */\r\nexport function rollDice(...dice: any[]): number {\r\n  let result = 0;\r\n  if (dice[0] instanceof DiceRolled || Array.isArray(dice)) {\r\n    dice.forEach((die) => {\r\n      if (Array.isArray(die)) {\r\n        die.forEach((subDie) => (result += rollDice(subDie)));\r\n      } else {\r\n        for (let i = 0; i < die.no; i++) {\r\n          result += die.multiplier * (rollOneDie(die) + die.modifier);\r\n        }\r\n      }\r\n    });\r\n  } else {\r\n    const { no, pips, modifier, multiplier } = dice;\r\n    result += rollDice(\r\n      new DiceRolled({ no, pips, modifier, multiplier } as DiceRolled)\r\n    );\r\n  }\r\n  return result;\r\n}\r\n\r\n/**\r\n * For a provided DiceRolled, generates a random number bounded by 1 and the\r\n * number of pips specified, with even probability between each possible result.\r\n * @param  {DiceRolled} die\r\n */\r\nfunction rollOneDie(die: DiceRolled): number {\r\n  return Math.floor(Math.random() * die.pips) + 1;\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}